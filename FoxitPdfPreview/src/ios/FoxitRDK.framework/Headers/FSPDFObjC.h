/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFObjC.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import <Foundation/Foundation.h>


#ifdef __cplusplus
extern "C" {
#endif

#import <CoreGraphics/CoreGraphics.h>
@class FSAnnotIconProviderCallback;
@class FSPDFDoc;
@class FSPDFPage;
@class FSPDFTextSelect;
@class FSBorderInfo;
@class FSPDFDictionary;
@class FSPDFObject;
@class FSPDFStream;
@class FSPDFArray;
@class FSNote;
@class FSBitmap;
@class FSForm;
@class FSFormField;
@class FSFormControl;
@class FSFormFiller;
@class FSDateTime;
@class FSFileReadCallback;
@class FSSignature;

/**
 * @name	Macro Definitions for Annotation Icon Name
 */
/**@{*/

/** @brief	Note icon name: Check. */
#define FS_ANNOT_ICONNAME_TEXT_CHECK                "Check"
/** @brief	Note icon name: Circle. */
#define FS_ANNOT_ICONNAME_TEXT_CIRCLE				"Circle"
/** @brief	Note icon name: Comment. */
#define FS_ANNOT_ICONNAME_TEXT_COMMENT				"Comment"
/** @brief	Note icon name: Cross. */
#define FS_ANNOT_ICONNAME_TEXT_CROSS				"Cross"
/** @brief	Note icon name: Help. */
#define FS_ANNOT_ICONNAME_TEXT_HELP					"Help"
/** @brief	Note icon name: Insert. */
#define FS_ANNOT_ICONNAME_TEXT_INSERT				"Insert"
/** @brief	Note icon name: Key. */
#define FS_ANNOT_ICONNAME_TEXT_KEY					"Key"
/** @brief	Note icon name: New Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_NEWPARAGRAPH			"NewParagraph"
/** @brief	Note icon name: Note. */
#define FS_ANNOT_ICONNAME_TEXT_NOTE					"Note"
/** @brief	Note icon name: Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_PARAGRAPH			"Paragraph"
/** @brief	Note icon name: Right Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTARROW			"RightArrow"
/** @brief	Note icon name: Right Pointer. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTPOINTER			"RightPointer"
/** @brief	Note icon name: Star. */
#define FS_ANNOT_ICONNAME_TEXT_STAR					"Star"
/** @brief	Note icon name: Up Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPARROW				"UpArrow"
/** @brief	Note icon name: Up-left Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPLEFTARROW			"UpLeftArrow"


/**@}*/

/**
 * @brief	Enumeration for rotation.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ROTATION {
	/** @brief	No rotation. */
	e_rotation0 = 0,
	/** @brief	Rotate 90 degrees in clockwise direction. */
	e_rotation90 = 1,
	/** @brief	Rotate 180 degrees in clockwise direction. */
	e_rotation180 = 2,
	/** @brief	Rotate 270 degrees in clockwise direction. */
	e_rotation270 = 3,
	/** @brief	Unknown rotation. */
	e_rotationUnknown = 4
};

/**
 * @brief	Enumeration for progress state.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PROGRESSSTATE {
	/** @brief	Progress state: any error occurs. */ 
	e_progressError = 0,
	/** @brief	Progress state: progress needs to be continued. */
	e_progressToBeContinued = 1,
	/** @brief	Progress state: progress is finished. */
	e_progressFinished = 2
};

/**
 * @brief	Enumeration for DIB format.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DIBFORMAT {
	/** @brief	Invalid DIB format. */
	e_dibInvalid = 0,
	/** @brief	DIB format: 24bpp format, with bits order "Blue, Green, Red". Blue is in the lowest order. */
	e_dibRgb = 0x018,
	/** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, not used". Blue is in the lowest order. */
	e_dibRgb32 = 0x020,
	/** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, Alpha". Blue is in the lowest order. */
	e_dibArgb = 0x220
};

/**
 * @brief	Enumeration for error code.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ERRORCODE {
	/** @brief	Success, and no error occurs. */
	e_errSuccess = 0,
	/** @brief	File error: file cannot be found or could not be opened. */
	e_errFile = 1,
	/** @brief	Format error: format is invalid. For files, this may also mean that file is corrupted. */
	e_errFormat = 2,
	/** 
	 * @brief	Password error: invalid password.
	 *
	 * @details	Usually, this error may occur when loading a PDF document with password. 
	 *			When meet this, user should call function {@link FSPDFDoc::load:} again, with correct password.
	 */
	e_errPassword = 3,
	/** @brief	Handler error: PDF document is encrypted by some unsupported security handler. */
	e_errHandler = 4,
	/** @brief	Certificate error: PDF document is encrypted by digital certificate and current user does not have the correct certificate. */
	e_errCertificate = 5,
	/** @brief	Unknown error: any unknown error occurs. */
	e_errUnknown = 6,
	/** @brief	License error: invalid license is used to initialize Foxit PDF SDK library. */
	e_errInvalidLicense = 7,
	/** @brief	Parameter error: value of any input parameter for a function is invalid. */
	e_errParam = 8,
	/** @brief	Unsupported error: some types are not supported.*/
	e_errUnsupported = 9,
	/** @brief	Memory error: out-of-memory error occurs.*/
	e_errOutOfMemory = 10,
    /** @brief	Security handler error: PDF document is encrypted by some unsupported security handler. */
    e_errSecurityHandler = 11
};

/**
 * @brief	Enumeration for display mode, which specifies how the document should be displayed when opened.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DISPLAYMODE {
	/** @brief	When document is opened, neither document outlines nor thumbnail images are visible. */
	e_displayUseNone = 0,
	/** @brief	When document is opened, document outlines (bookmarks) are visible. */
	e_displayUseOutlines = 1,
	/** @brief	When document is opened, thumbnail images are visible. */
	e_displayUseThumbs = 2,
	/** @brief	When document is opened, full-screen mode, with no menu bar, window controls, or any other windows are visible. */
	e_displayFullScreen = 3,
	/** @brief	When document is opened, optional content group panels are visible. */
	e_displayUseOC = 4,
	/** @brief	When document is opened, attachment panels are visible. */
	e_displayUseAttachment = 5
};

/**
 * @brief	Enumeration for zoom mode.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ZOOMMODE {
	/** 
	 * @brief	Display page with a specific position and a specific zoom factor.
	 *
	 * @details	If this is used, that means the specific position of the page will be treated as the left-top position when the page is rendered 
	 *			and this position should be at the upper-left corner of the display area, 
	 *			and the contents of the page should be magnified by the zoom factor.
	 */
	e_zoomXYZ = 1,
	/** 
	 * @brief	Fit the entire page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire page within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the page within the window in the other dimension.
	 */
	e_zoomFitPage = 2,
	/** 
	 * @brief	Fit the entire width of the page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire width of the page within the display area.
	 */ 
	e_zoomFitHorz = 3,
	/** 
	 * @brief	Fit the entire height of the page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire height of the page within the display area.
	 */ 
	e_zoomFitVert = 4,
	/** 
	 * @brief	Fit the page content in a specific rectangle entirely within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the page content in the specific rectangle entirely within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the rectangle within the display area in the other dimension.
	 */ 
	e_zoomFitRect = 5,
	/** 
	 * @brief	Fit the bounding box of page entirely within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit its bounding box entirely within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the bounding box within the display area in the other dimension.
	 */ 
	e_zoomFitBBox = 6,
	/** 
	 * @brief	Fit the entire width of the page's bounding box within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire width of the page's bounding box within the display area.
	 */ 
	e_zoomFitBHorz = 7,
	/** 
	 * @brief	Fit the entire height of the page's bounding box within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire height of the page's bounding box within the display area.
	 */ 
	e_zoomFitBVert = 8
};

/**
 * @brief	Enumeration for module name.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_MODULENAME {
	/** @brief	Standard module. */
	e_moduleNameStandard = 0,
	/** @brief	Annotation module. */
	e_moduleNameAnnotation = 1,
};

/**
 * @brief	Enumeration for module right.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_MODULERIGHT {
	/** @brief	Module right: unknown. */
	e_moduleRightUnknown = -1,
	/** @brief	Module right: no right. */
	e_moduleRightNone = 0,
	/** @brief	Module right: read. */
	e_moduleRightRead = 1,
	/** @brief	Module right: write, including read. */
	e_moduleRightWrite = 2
};

/**
 * @brief	Enumeration for default appearance flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_DEFAULTAPFLAGS {
    /** @brief	Indicates properties {@link FSDefaultAppearance::font} is meaningful. */
    e_defaultAPFont = 0x0001,
    /** @brief	Indicates properties {@link FSDefaultAppearance::textColor} is meaningful. */
    e_defaultAPTextColor = 0x0002,
     /** @brief	Indicates property {@link FSDefaultAppearance::fontSize} is meaningful. */
    e_defaultAPFontSize = 0x0004
};
    
/**
 * @brief	Enumeration for font styles.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_FONTSTYLES {
    /** @brief	Font style: fixed pitch. */
    e_fontStyleFixedPitch = 0x0001,
    /** @brief	Font style: serif. */
    e_fontStyleSerif = 0x0002,
    /** @brief	Font style: symbolic. */
    e_fontStyleSymbolic = 0x0004,
    /** @brief	Font style: script. */
    e_fontStyleScript = 0x0008,
    /** @brief	Font style: non-symbolic. */
    e_fontStyleNonSymbolic = 0x0020,
    /** @brief	Font style: italic. */
    e_fontStyleItalic = 0x0040,
    /** @brief	Font style: all cap. */
    e_fontStyleAllCap = 0x10000,
    /** @brief	Font style: small cap. */
    e_fontStylesSmallCap = 0x20000,
    /** @brief	Font style: force bold. */
    e_fontStylesBold = 0x40000,
};
    
/**
 * @brief	Enumeration for font charset.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_FONTCHARSET {
    /** @brief	Font charset: ANSI (United States, Western Europe). */
    e_fontCharsetANSI = 0,
    /** @brief	Font charset: System default, for unknown or mapping purpose. */
    e_fontCharsetDefault = 1,
    /** @brief	Font charset: Standard symbols. */
    e_fontCharsetSymbol = 2,
    /** @brief	Font charset: Japanese (Shift-JIS). */
    e_fontCharsetShift_JIS = 128,
    /** @brief	Font charset: Korean (Wansung). */
    e_fontCharsetHangeul = 129,
    /** @brief	Font charset: Simplified Chinese. */
    e_fontCharsetGB2312 = 134,
    /** @brief	Font charset: Traditional Chinese. */
    e_fontCharsetChineseBig5 = 136,
    /** @brief	Font charset: Thai. */
    e_fontCharsetThai = 222,
    /** @brief	Font charset: Eastern European. */
    e_fontCharsetEastEurope = 238,
    /** @brief	Font charset: Russian. */
    e_fontCharsetRussian = 204,
    /** @brief	Font charset: Greek. */
    e_fontCharsetGreek = 161,
    /** @brief	Font charset: Turkish. */
    e_fontCharsetTurkish = 162,
    /** @brief	Font charset: Hebrew. */
    e_fontCharsetHebrew = 177,
    /** @brief	Font charset: Arabic. */
    e_fontCharsetArabic = 178,
    /** @brief	Font charset: Baltic. */
    e_fontCharsetBaltic = 186
};

/**
 * @brief	Enumeration for font charset.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_STANDARDFONTID {
    /** @brief	Standard font: Courier. */
    e_fontStandardIDCourier = 0,
    /** @brief	Standard font: Courier-Bold. */
    e_fontStandardIDCourierB = 1,
    /** @brief	Standard font: Courier-BoldOblique, Bold italic. */
    e_fontStandardIDCourierBI = 2,
    /** @brief	Standard font: Courier-Oblique, Italic. */
    e_fontStandardIDCourierI = 3,
    /** @brief	Standard font: Helvetica. */
    e_fontStandardIDHelvetica = 4,
    /** @brief	Standard font: Helvetica-Bold. */
    e_fontStandardIDHelveticaB = 5,
    /** @brief	Standard font: Helvetica-BoldOblique, Bold italic. */
    e_fontStandardIDHelveticaBI = 6,
    /** @brief	Standard font: Helvetica-Oblique, Italic. */
    e_fontStandardIDHelveticaI = 7,
    /** @brief	Standard font: Times-Roman. */
    e_fontStandardIDTimes = 8,
    /** @brief	Standard font: Times-Bold. */
    e_fontStandardIDTimesB = 9,
    /** @brief	Standard font: Times-BoldItalic. */
    e_fontStandardIDTimesBI = 10,
    /** @brief	Standard font: Times-Italic. */
    e_fontStandardIDTimesI = 11,
    /** @brief	Standard font: Symbol. */
    e_fontStandardIDSymbol = 12,
    /** @brief	Standard font: ZapfDingbats. */
    e_fontStandardIDZapfDingbats = 13
};
    
/**
 * @brief	Enumeration for point type in a PDF path.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PATHPOINTTYPE {
    /** @brief      Indicates that the point is the first point of a figure. */
    e_pointTypeMoveTo = 1,
    /** @brief      Indicates that a line is drawn from the previous point to this point. */
    e_pointTypeLineTo = 2,
    /** @brief      Indicates that a line is drawn from the previous point to this point,
      *			and this point will also be connected to the nearest {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} point before this point,
      *			in order to close current figure.
      */
    e_pointTypeLineToCloseFigure = 3,
    /** @brief      Indicates that this point is a control point or ending point for a Bezier spline. */
    e_pointTypeBezierTo = 4,
    /** @brief      Indicates that this point is the ending point for a Bezier spline,
      *			and this point will also be connected to the nearest {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} point before this point,
      *			in order to close current figure.
      */
    e_pointTypeBezierToCloseFigure = 5
};
  
/**
 * @brief   Enumeration for flatten options.
 *
 * @details Values of this enumeration indicate the option of flatten.
 */
enum FS_FLATTENOPTIONS {
    /** @brief  Flatten contents for all. */
    e_flattenOptionAll    = 0,
    /** @brief  Flatten a PDF page without annotations.  */
    e_flattenOptionNoAnnot = 0x0001,
    /** @brief  Flatten a PDF page without form controls.  */
    e_flattenOptionNoFormControl = 0x0002
};
   
/**
 * @brief	Enumeration for markup annotation's state model.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ANNOTSTATEMODEL {
    /**
      * @brief	Markup annotation state model: marked.
      */
    e_annotStateModelMarked = 1,
    /**
      * @brief	Markup annotation state model: review.
      */
    e_annotStateModelReview = 2
};

/**
 * @brief	Enumeration for markup annotation's state.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ANNOTSTATE {
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked})
      *			The annotation has been marked by the user.
      */
    e_annotStateMarked = 1,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked})
      *			The annotation has has not been marked by the user.
      */
    e_annotStateUnmarked = 2,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
      *			The user agrees with the change.
      */
    e_annotStateAccepted = 3,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
      *			The user disagrees with the change.
      */
    e_annotStateRejected = 4,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
      *			The change has been cancelled.
      */
    e_annotStateCancelled = 5,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
      *			The change has been completed.
      */
    e_annotStateCompleted = 6,
    /**
      * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
      *			The user has indicated nothing about the change.
      */
    e_annotStateNone = 7
};
    
/**
 * @brief	Enumeration for some PDF annotation property.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ANNOTPROPERTY {
    /**
      * @brief	Annotation property: modified date.
      */
    e_annotPropertyModifiedDate		= 0,
    /**
      * @brief	Annotation property: creation date.
      *
      * @details	Only markup annotations can have creation date property.
      */
    e_annotPropertyCreationDate		= 1,
    /**
      * @brief	Annotation property: border color
      */
    e_annotPropertyBorderColor		= 2,
    /**
      * @brief	Annotation property: fill color
      *
      * @details	Only following annotations can have fill color property:<br>
      *			square, circle, free text, line, polygon, polyline.
      */
    e_annotPropertyFillColor		= 3
};
    
/**
 * @brief	Class to represent a callback object to notify the Foxit PDF SDK events.
 * 
 * @details	All the pure virtual functions in this class are used as callback functions and should be implemented by user. 
 *			An implemented ::FSNotifier object can be set to Foxit PDF SDK by function {@link FSLibrary::setNotifier:}.
 */
@interface FSNotifier : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	A callback function used to be triggered when Foxit PDF SDK runs out of the memory.
 */
-(void)OnOutOfMemory;
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Structure for identity properties of current user, which is used for callback function {@link FSActionHandler::getIdentityProperties}.
 */
@interface FSIdentityProperties : NSObject
{
void *swigCPtr;
BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Set value.
 *
 * @param[in]	corporation	The corporation name, in UTF-8 encoding.
 * @param[in]	email		The email address, in UTF-8 encoding.
 * @param[in]	loginName	The login name, in UTF-8 encoding. Usually, this is the name used to log in current operating system.
 * @param[in]	name		The user name, in UTF-8 encoding.
 */
-(void)set: (NSString *)corporation email: (NSString *)email loginName: (NSString *)loginName name: (NSString *)name;
/** @brief      Set the corporation name, in UTF-8 encoding. */
-(void)setCorporation: (NSString *)value;
/** @brief      Get the corporation name. */
-(NSString *)getCorporation;
/** @brief      Set the email address, in UTF-8 encoding. */
-(void)setEmail: (NSString *)value;
/** @brief      Get the email address. */
-(NSString *)getEmail;
/** @brief      Set the login name, in UTF-8 encoding. Usually, this is the name used to log in current operating system. */
-(void)setLoginName: (NSString *)value;
/** @brief      Get the login name. */
-(NSString *)getLoginName;
/** @brief      Set the user name, in UTF-8 encoding. */
-(void)setName: (NSString *)value;
/** @brief      Get the user name. */
-(NSString *)getName;
/** @brief      Init the object. */
-(id)init;
/** @brief      Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represents a callback object for performing PDF actions.
 *
 * @details	All the pure virtual functions in this class are used as callback functions
 *			and should be implemented by user, to perform PDF actions, such as javascript actions.<br>
 *			For optional callback functions, empty implementation is allowed.
 */
@interface FSActionHandler : NSObject
{
void *swigCPtr;
BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Optional callback function used to receive current page index.
 *
 * @param[in]	pdfDoc		The PDF document object.
 *
 * @return	Current page index.
 *			The value should be stared from 0 and less than page count of the specified document.
 */
-(int)getCurrentPage:(FSPDFDoc*)pdfDoc;

/**
 * @brief	Optional callback function used to set the current page by index.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index which is used to change current page.
 *							The value would be stared from 0 and less than page count of the specified document.
 */
-(void)setCurrentPage:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;

/**
 * @brief	Optional callback function used to receive current displaying rotation of the page on PDF viewer.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index, to specify which page's rotation is to be retrieved.
 *							The value would be stared from 0 and less than page count of the specified document.
 *
 * @return	The rotation of specified page.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and it should be one of these values.
 */
-(enum FS_ROTATION)getPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;

/**
 * @brief	Optional callback function used to set the rotation value of a page on PDF viewer.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index, to specify which page's rotation is to be changed.
 *							The value would be stared from 0 and less than page count of the specified document.
 * @param[in]	rotation	New rotation value.
 *							Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and it would be one of these values.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex rotation:(enum FS_ROTATION)rotation;

/**
 * @brief	Optional callback function used to pop up a dialog to show warnings or hints.
 *
 * @param[in]	msg			The message string to be displayed in the dialog. It should be in UTF-8 encoding.
 * @param[in]	title		The title of the dialog. It should be in UTF-8 encoding.
 * @param[in]	type		Type of button group. It can be one of following values:<br>
 *							<ul>
 *							<li>0: OK;(default value.)</li>
 *							<li>1: OK, Cancel;</li>
 *							<li>2: Yes, NO; </li>
 *							<li>3: Yes, NO, Cancel.</li>
 *							</ul>
 * @param[in]	icon		Icon type. It can be one of following values:<br>
 *							<ul>
 *							<li>0: Error;(default value.)</li>
 *							<li>1: Warning;</li>
 *							<li>2: Question;</li>
 *							<li>3: Status.</li>
 *							</ul>
 *
 * @return	The return value should be one of following values:<br>
 *			<ul>
 *			<li>1: OK;</li>
 *			<li>2: Cancel; </li>
 *			<li>3: NO;</li>
 *			<li>4: Yes;</li>
 *			</ul>
 */
-(int)alert: (NSString *)msg title: (NSString *)title type: (int)type icon: (int)icon;

/**
 * @brief	Optional callback function used to get identity properties of current user.
 *
 * @return	A FSIdentityProperties object that receives the identity properties of current user.
 */
-(FSIdentityProperties*)getIdentityProperties;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to access a file specification.
 *
 * @details	A PDF file can refer to the contents of another file by using a file specification.
 *			File specification can simply represents the file path of another file,
 *			or represents the whole content of another file, which is embedded to current PDF file.
 */
@interface FSFileSpec : NSObject
{
void *swigCPtr;
BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Create a file specification object.
 *
 * @param[in]	pdfDoc	The PDF document object, to which the new file specification object will belongs.
 *
 * @return	A new file specification object.
 *			If there is any error, this function will return <b>nil</b>.
 */
+(FSFileSpec*)create:(FSPDFDoc*)pdfDoc;

/**
 * @brief	Get the file name.
 *
 * @return	The file name, in UTF-8 encoding.
 *			If no file name can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getFileName;
/**
 * @brief	Set the file name.
 *
 * @details	This function is required for a newly created file specification object.
 *
 * @param[in]	fileName	The file name to be set, in UTF-8 encoding. It should not be <b>nil</b>.
 */
-(void)setFileName:(NSString*)fileName;
/**
 * @brief	Get the size of embedded file.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	File size of embedded file.
 */
-(unsigned long long)getFileSize;
/**
 * @brief	Get the file data of embedded file.
 *
 * @return	A file read object and user can call methods of <CODE>FileRead</CODE> to read the file data.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSFileReadCallback*)getFileData;
/**
 * @brief	Embed the whole content of a file which is specified by input file path.
 *
 * @details	When this function succeeds, the whole content of specified file will be embedded to the PDF document that current file specification belongs to.
 *
 * @param[in]	filePath	A full path of a local file, in UTF-8 encoding.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)embed:(NSString*)filePath;
/**
 * @brief	Check whether current file specification object represents an embedded file or not.
 *
 * @return	<b>YES</b> means current file specification object represent an embedded file. <br>
 *			<b>NO</b> means current file specification object does not represent an embedded file.
 */
-(BOOL)isEmbedded;
/**
 * @brief	Get the descriptive text associated with current file specification.
 *
 * @return	The descriptive text, in UTF-8 encoding.
 *			If no descriptive text can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getDescription;
/**
 * @brief	Set the descriptive text associated with current file specification.
 *
 * @param[in]	description		New descriptive text to be set, in UTF-8 encoding.
 *								It should not be <b>nil</b>.
 */
-(void)setDescription:(NSString*)description;
/**
 * @brief	Get creation date and time about when the embedded file was created.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	The creation date time of embedded file.
 *			If no creation data time is found or there is any error, this function will return a {@link ::FSDateTime} will all value 0.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Set the creation date and time for the embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @param[in]	dateTime	New creation date and time to be set.
 *							It should not be <b>nil</b> and its value should be valid.
 */
-(void)setCreationDateTime:(const FSDateTime*)dateTime;
/**
 * @brief	Get modified date and time about when the embedded file was last modified.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	The modified date time of embedded file.
 *			If no creation data time is found or there is any error, this function will return a {@link ::FSDateTime} will all value 0.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set last modified date and time for the embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @param[in]	dateTime	New last modified date and time to be set.
 *							It should not be <b>nil</b> and its value should be valid.
 */
-(void)setModifiedDateTime:(const FSDateTime*)dateTime;
/**
 * @brief	Get the checksum for embedded file.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.<br>
 *			A 16-byte string that is the checksum of the bytes of the uncompressed embedded file.
 *			The checksum is calculated by applying the standard MD5 message-digest algorithm
 *			to the bytes of the embedded file stream.
 *
 * @return	The checksum string.
 *			If no checksum can be found or there is any error, this function will return an empty string.
 */
-(NSData*)getChecksum;
/**
 * @brief	Set  the checksum for embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.<br>
 *			A 16-byte string that is the checksum of the bytes of the uncompressed embedded file.
 *			The checksum is calculated by applying the standard MD5 message-digest algorithm
 *			to the bytes of the embedded file stream.
 *
 * @param[in]	checksum		New checksum to be set.
 */
-(void)setChecksum:(NSData*)checksum;
/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to represent the library management for global configuration.
 *
 * @details	It contains functions to initialize/re-initialize/release Foxit PDF SDK library, and also contains functions for global use.<br>
 *			Any application should load Foxit PDF SDK by function {@link FSLibrary::init:key:} before calling any other Foxit PDF SDK functions.
 *			When there is no need to use Foxit PDF SDK any more, call function {@link FSLibrary::release}.
 */
@interface FSLibrary : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Initialize Foxit PDF SDK Library, with valid license information.
 *
 * @details	This function should be called first before other functions in Foxit PDF SDK can be called.
 *
 * @param[in]	sn		String of sn information, which can be retrieved from "SN=" part in key file "rdk_sn.txt".
 * @param[in]	key		String of key information, which can be retrieved from "Sign=" part in key file "rdk_key.txt".
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success.
 *			{@link FS_ERRORCODE::e_errInvalidLicense} means input license information is invalid.
 *			{@link FS_ERRORCODE::e_errParam} means parameter <i>sn</i> or <i>key</i> is <b>nil</b> or empty string.
 */
+(enum FS_ERRORCODE)init: (NSString *)sn key: (NSString *)key;
/**
 * @brief	Reinitialize Foxit PDF SDK Library.
 *
 * @details	When user meets out-of-memory error, user can call this function to reinitialize Foxit PDF SDK Library.
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success.
 *			For more information about error code values, please refer to {@link FS_ERRORCODE::e_errSuccess FS_ERRORCODE::e_errXXX} values.
 */
+(enum FS_ERRORCODE)reinit;
/**
 * @brief	Release all resource allocated by Foxit PDF SDK Library.
 *
 * @details	User can call this function to release all memory blocks allocated by the library.
 *			After this function is called, user should not call any function of Foxit PDF SDK.
 */
+(void)release;
/**
 * @brief	Get the version of current Foxit PDF SDK library.
 *
 * @return	The library version string.
 */
+(NSString*)getVersion;

/**
 * @brief	Get the authority of a specific module.
 *
 * @param[in]	module	Module name. It should be one of {@link FS_MODULENAME::e_moduleNameStandard FS_MODULENAME::e_moduleNameXXX} values.
 *
 * @return	The right of specific module. It would be one of {@link FS_MODULERIGHT::e_moduleRightUnknown FS_MODULENAME::e_moduleRightXXX} values.
 */
+(enum FS_MODULERIGHT)getModuleRight: (enum FS_MODULENAME)module;
/**
 * @brief	Set a customized annotation icon provider to Foxit PDF SDK.
 *
 * @details	User can call this function to set a customized icon provider for annotation.
 *			If this function has been called several times, Foxit PDF SDK will only keep the last icon provider.
 *			Foxit PDF SDK will use a default standard icon provider if there is no provider been set.
 *
 * @param[in]	iconProvider		Pointer to a customized annotation icon provider, which is implemented based on class ::FSAnnotIconProviderCallback.
 *									If this is <b>nil</b>, customized annotation icon provider will be removed from Foxit PDF SDK and default standard icon provider will be used instead.
 *									Application should ensure this icon provider object valid until it has been removed from Foxit PDF SDK or function {@link FSLibrary::release} is called.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @note	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers
 *			by callback functions {@link FSAnnotIconProviderCallback::getProviderID} and {@link FSAnnotIconProviderCallback::getProviderVersion}.
 */
+(BOOL)setAnnotIconProvider: (FSAnnotIconProviderCallback*)iconProvider;
/**
 * @brief	Set a notifier to Foxit PDF SDK.
 *
 * @details	User can call this function to set a notifier to Foxit PDF SDK, so that when SDK events (such as OOM) occurs, user would be notified.
 *
 * @param[in]	notifier	A ::FSNotifier object. User should ensure all the callback functions have been implemented in application level.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setNotifier: (FSNotifier*)notifier;

/**
 * @brief	Set an action handler to Foxit PDF SDK, in aid of performing PDF actions.
 *
 * @details	User should implement an action handler and call this function to set the action handler to Foxit PDF SDK if PDF actions need to be performed,
 *			such as filling a PDF form.
 *
 * @param[in]	actionHandler	A customized action handler object.
 *								User should ensure all the callback functions have been implemented in application level.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setActionHandler:(FSActionHandler*)actionHandler;

/**
 * @brief	Register the default signature handler to Foxit PDF SDK for signing and verifying signature.
 *
 * @details	This function should be called before signing or verifying signature process, if user wants to sign or verify signature by default signature handler.
 *			The default signature handler is AdobePPKLite handler: filter is "Adobe.PPKLite", and sub filter is "adbe.pkcs7.detached".
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)registerDefaultSignatureHandler;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/** @brief	Class represents a recovery manager to recover SDK when out-of-memory error occurs. It will help to clear the memory, free the cache and reload the document. */
@interface FSRecoveryManager : NSObject
/**
 * @brief	Receive a shared instance of recovery manager.
 *
 * @return	The recovery manager instance.
 */
+(FSRecoveryManager*)sharedInstance;
/**
 * @brief	Reload the specified PDF document.
 *
 * @details	When there is an OOM, user may call this function to reload the document.
 *			The editing content will not be saved because there is no more memory left.
 *
 * @param[in]	pdfDoc	The PDF document to be reloaded. It will be invalid when the document reloaded.
 *
 * @return	The new document object.
 */
-(FSPDFDoc*) reloadDoc:(FSPDFDoc*)pdfDoc;
@end
	

/************************************************************************************************
 *									Basic data structures or classes							*
 *************************************************************************************************/

/**
 * @brief	Class to represent a point, in floating point.
 */  
@interface FSPointF : NSObject

{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	X coordinate value, in floating point.*/
@property (nonatomic,assign) float x;
/** @brief	Y coordinate value, in floating point.*/
@property (nonatomic,assign) float y;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current point.
 *
 * @param[in]	x	Horizontal coordinate value for the point, in floating point.
 * @param[in]	y	Vertical coordinate value for the point, in floating point.
 */
-(void)set: (float)x y: (float)y;
/** 
 * @brief	Set horizontal coordinate value of the point, in floating point.
 * 
 * @param[in]	value	Value for horizontal coordinate, in floating point.
 */
-(void)setX: (float)value;
/** 
 * @brief	Get horizontal coordinate value of the point, in floating point.
 *
 * @return	Horizontal coordinate value, in floating point.
 */
-(float)getX;
/** 
 * @brief	Set vertical coordinate value of the point, in floating point.
 * 
 * @param[in]	value	Value for vertical coordinate, in floating point.
 */
-(void)setY: (float)value;
/** 
 * @brief	Get vertical coordinate value of the point, in floating point.
 *
 * @return	Vertical coordinate value, in floating point.
 */
-(float)getY;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**  @brief	class for offset, in float. */
typedef  FSPointF FSOffset;
    
/**
 * @brief	Class to represent a rectangle, in floating point.
 */
@interface FSRectF : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in float. */
@property (nonatomic,assign) float left;
/** @brief	Bottom coordinate value, in float. */
@property (nonatomic,assign) float bottom;
/** @brief	Right coordinate value, in float */
@property (nonatomic,assign) float right;
/** @brief	Top coordinate value, in float. */
@property (nonatomic,assign) float top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in floating point.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in floating point.
 * @param[in]	right		Right coordinate value for the rectangle, in floating point.
 * @param[in]	top			Top coordinate value for the rectangle, in floating point.
 */
-(void)set: (float)left bottom: (float)bottom right: (float)right top: (float)top;
/** 
 * @brief	Set left coordinate value , in floating point.
 * 
 * @param[in]	value	Value for left coordinate, in floating point.
 */
-(void)setLeft: (float)value;
/** 
 * @brief	Get left coordinate value, in floating point.
 *
 * @return	Left coordinate value, in floating point.
 */
-(float)getLeft;
/** 
 * @brief	Set bottom coordinate value , in floating point.
 * 
 * @param[in]	value	Value for bottom coordinate, in floating point.
 */
-(void)setBottom: (float)value;
/** 
 * @brief	Get bottom coordinate value, in floating point.
 *
 * @return	Bottom coordinate value, in floating point.
 */
-(float)getBottom;
/** 
 * @brief	Set right coordinate value , in floating point.
 * 
 * @param[in]	value	Value for right coordinate, in floating point.
 */
-(void)setRight: (float)value;
/** 
 * @brief	Get right coordinate value, in floating point.
 *
 * @return	Right coordinate value, in floating point.
 */
-(float)getRight;
/** 
 * @brief	Set top coordinate value , in floating point.
 * 
 * @param[in]	value	Value for top coordinate, in floating point.
 */
-(void)setTop: (float)value;
/** 
 * @brief	Get top coordinate value, in floating point.
 *
 * @return	Top coordinate value, in floating point.
 */
-(float)getTop;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a rectangle, in integer.
 */
@interface FSRectI : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in integer. */
@property (nonatomic,assign) int left;
/** @brief	Bottom coordinate value, in integer. */
@property (nonatomic,assign) int bottom;
/** @brief	Right coordinate value, in integer. */
@property (nonatomic,assign) int right;
/** @brief	Top coordinate value, in integer. */
@property (nonatomic,assign) int top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in integer.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in integer.
 * @param[in]	right		Right coordinate value for the rectangle, in integer.
 * @param[in]	top			Top coordinate value for the rectangle, in integer.
 */
-(void)set: (int)left top: (int)top right: (int)right bottom: (int)bottom;
/** 
 * @brief	Set left coordinate value, in integer.
 * 
 * @param[in]	value	Value for left coordinate, in integer.
 */
-(void)setLeft: (int)value;
/** 
 * @brief	Get left coordinate value, in integer.
 *
 * @return	Left coordinate value, in integer.
 */
-(int)getLeft;
/** 
 * @brief	Set top coordinate value, in integer.
 * 
 * @param[in]	value	Value for top coordinate, in integer.
 */
-(void)setTop: (int)value;
/** 
 * @brief	Get top coordinate value, in integer.
 *
 * @return	Top coordinate value, in integer.
 */
-(int)getTop;
/** 
 * @brief	Set right coordinate value, in integer.
 * 
 * @param[in]	value	Value for right coordinate, in integer.
 */
-(void)setRight: (int)value;
/** 
 * @brief	Get right coordinate value, in integer.
 *
 * @return	Right coordinate value, in integer.
 */
-(int)getRight;
/** 
 * @brief	Set bottom coordinate value, in integer.
 * 
 * @param[in]	value	Value for bottom coordinate, in integer.
 */
-(void)setBottom: (int)value;
/** 
 * @brief	Get bottom coordinate value, in integer.
 *
 * @return	Bottom coordinate value, in integer.
 */
-(int)getBottom;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a matrix, used for transformation between two coordinate systems.
 *
 * @details	The transformation between two coordinate systems is represented by a 3-by-3
 *			transformation matrix written as follows:
 *			<pre>
 *			|a  b  0|
 *			|c  d  0|
 *			|e  f  1|
 *			</pre>
 *			Because a transformation matrix has only six elements that can be changed, it is
 *			usually specified in PDF as the six-element array [a b c d e f].
 */
@interface FSMatrix : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Coefficient a. */
@property (nonatomic,assign) float a;
/** @brief	Coefficient b. */
@property (nonatomic,assign) float b;
/** @brief	Coefficient c. */
@property (nonatomic,assign) float c;
/** @brief	Coefficient d. */
@property (nonatomic,assign) float d;
/** @brief	Coefficient e. */
@property (nonatomic,assign) float e;
/** @brief	Coefficient f. */
@property (nonatomic,assign) float f;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set the value for current matrix.
 *
 * @param[in]	a		Value for coefficient a.
 * @param[in]	b		Value for coefficient b.
 * @param[in]	c		Value for coefficient c.
 * @param[in]	d		Value for coefficient d.
 * @param[in]	e		Value for coefficient e.
 * @param[in]	f		Value for coefficient f.
 */
-(void)set: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f;
/**
 * @brief	Get the reverse matrix.
 *
 * @return	The reverse matrix.
 */
-(FSMatrix*)getReverse;
/**
 * @brief	Transform a float point.
 *
 * @param[in]	point	A float point to be transformed.
 *
 * @return	The transformed point.
 */
-(FSPointF*)transform: (FSPointF*)point;
/**
 * @brief	Transform a float rectangle.
 *
 * @param[in]	rect	A float rectangle to be transformed.
 *
 * @return	The transformed rectangle.
 */
-(FSRectF*)transformRect: (FSRectF*)rect;
/** 
 * @brief	Set coefficient a.
 * 
 * @param[in]	value	Value for coefficient a.
 */
-(void)setA: (float)value;
/** 
 * @brief	Get coefficient a.
 *
 * @return	Coefficient a value.
 */
-(float)getA;
/** 
 * @brief	Set coefficient b.
 * 
 * @param[in]	value	Value for coefficient b.
 */
-(void)setB: (float)value;
/** 
 * @brief	Get coefficient b.
 *
 * @return	Coefficient b value.
 */
-(float)getB;
/** 
 * @brief	Set coefficient c.
 * 
 * @param[in]	value	Value for coefficient c.
 */
-(void)setC: (float)value;
/** 
 * @brief	Get coefficient c.
 *
 * @return	Coefficient c value.
 */
-(float)getC;
/** 
 * @brief	Set coefficient d.
 * 
 * @param[in]	value	Value for coefficient d.
 */
-(void)setD: (float)value;
/** 
 * @brief	Get coefficient d
 *
 * @return	Coefficient d value.
 */
-(float)getD;
/** 
 * @brief	Set coefficient e.
 * 
 * @param[in]	value	Value for coefficient e.
 */
-(void)setE: (float)value;
/** 
 * @brief	Get coefficient e
 *
 * @return	Coefficient e value.
 */
-(float)getE;
/** 
 * @brief	Set coefficient f.
 * 
 * @param[in]	value	Value for coefficient f.
 */
-(void)setF: (float)value;
/** 
 * @brief	Get coefficient f
 *
 * @return	Coefficient f value.
 */
-(float)getF;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** @brief	Class to represent date, time and timezone. */
@interface FSDateTime : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Year. It should be a four-digit number, such as 2014. */
@property (nonatomic,assign) unsigned short year;
/** @brief	Month. Valid range: from 1 to 12. */
@property (nonatomic,assign) unsigned short month;
/** @brief	Day of month. Valid range: from 1 to 31. */
@property (nonatomic,assign) unsigned short day;
/** @brief	Hour. Valid range: from 0 to 23. */
@property (nonatomic,assign) unsigned short hour;
/** @brief	Minute. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short minute;
/** @brief	Second. Valid range: from 0 to 60. 60 for leap second. */
@property (nonatomic,assign) unsigned short second;
/** @brief	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable. */
@property (nonatomic,assign) unsigned short millisecond;
/**
 * @brief	Hour of time zone. Valid range: from -12 to 12.
 *
 * @details	Positive value for the eastern time zone, and negative value for the western time zone.
 */
@property (nonatomic,assign) short UTHourOffset;
/** @brief	Minute of time zone. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short UTMinuteOffset;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	year			Year. It should be a four-digit number, such as 2014.
 * @param[in]	month			Month. Valid range: from 1 to 12.
 * @param[in]	day				Day of month. Valid range: from 1 to 31.
 * @param[in]	hour			Hour. Valid range: from 0 to 23.
 * @param[in]	minute			Minute. Valid range: from 0 to 59.
 * @param[in]	second			Second. Valid range: from 0 to 60. 60 for leap second.
 * @param[in]	millisecond	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable.
 * @param[in]	UTHourOffset	Hour of time zone. Valid range: from -12 to 12.
 *								Positive value for the eastern time zone, and negative value for the western time zone. 
 * @param[in]	UTMinuteOffset	Minute of time zone. Valid range: from 0 to 59.
 */
-(void)set: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second millisecond: (unsigned short)millisecond UTHourOffset: (short)UTHourOffset UTMinuteOffset: (unsigned short)UTMinuteOffset;
/** 
 * @brief	Set value for year.
 * 
 * @param[in]	value	Value for year. It should be a four-digit number, such as 2014.
 */
-(void)setYear: (unsigned short)value;
/** 
 * @brief	Get value for year.
 *
 * @return	Value for year. It would be a four-digit number, such as 2014.
 */
-(unsigned short)getYear;
/** 
 * @brief	Set value for month.
 * 
 * @param[in]	value	Value for month. Valid range: from 1 to 12.
 */
-(void)setMonth: (unsigned short)value;
/** 
 * @brief	Get value for month.
 * 
 * @return	Value for month. Valid range: from 1 to 12.
 */
-(unsigned short)getMonth;
/** 
 * @brief	Set value for day of month.
 * 
 * @param[in]	value	Value for day of month. Valid range: from 1 to 31.
 */
-(void)setDay: (unsigned short)value;
/** 
 * @brief	Get value for day of month.
 * 
 * @return	Value for day of month. Valid range: from 1 to 31.
 */
-(unsigned short)getDay;
/** 
 * @brief	Set value for hour.
 * 
 * @param[in]	value	Value for hour. Valid range: from 0 to 23.
 */
-(void)setHour: (unsigned short)value;
/** 
 * @brief	Get value for hour.
 * 
 * @return	Value for hour. Valid range: from 0 to 23.
 */
-(unsigned short)getHour;
/** 
 * @brief	Set value for minute.
 * 
 * @param[in]	value	Value for minute. Valid range: from 0 to 59.
 */
-(void)setMinute: (unsigned short)value;
/** 
 * @brief	Get value for minute.
 * 
 * @return	Value for minute. Valid range: from 0 to 59.
 */
-(unsigned short)getMinute;
/** 
 * @brief	Set value for second.
 * 
 * @param[in]	value	Value for second. Valid range: from 0 to 60. 60 for leap second.
 */
-(void)setSecond: (unsigned short)value;
/** 
 * @brief	Get value for second.
 * 
 * @return	Value for second. Valid range: from 0 to 60. 60 for leap second.
 */
-(unsigned short)getSecond;
/** 
 * @brief	Set value for millisecond.
 * 
 * @param[in]	value	Value for millisecond. Valid range: from 0 to 999.
 *
 * @note	Currently, PDF standard does not support millisecond, so user can omit this field if this is not applicable.
 */
-(void)setMillisecond: (unsigned short)value;
/** 
 * @brief	Get value for millisecond.
 * 
 * @return	Value for millisecond. Valid range: from 0 to 999.
 *			Currently, this function would always return 0 because PDF standard does not support it.
 */
-(unsigned short)getMillisecond;
/** 
 * @brief	Set the offset from Universal Coordinated Time (UTC) by hours.
 * 
 * @param[in]	value	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *						Positive value for the eastern time zone, and negative value for the western time zone.
 */
-(void)setUTHourOffset: (short)value;
/** 
 * @brief	Get the offset from Universal Coordinated Time (UTC) by hours.
 * 
 * @return	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *			Positive value for the eastern time zone, and negative value for the western time zone.
 */
-(short)getUTHourOffset;
/** 
 * @brief	Set the offset from Universal Coordinated Time (UTC) by minutes.
 * 
 * @param[in]	value	Minutes offset from UTC minute. Valid range: from 0 to 59.
 */
-(void)setUTMinuteOffset: (unsigned short)value;
/** 
 * @brief	Get the offset from Universal Coordinated Time (UTC) by minutes.
 * 
 * @return	Minutes offset from UTC minute. Valid range: 0 to 59.
 */
-(unsigned short)getUTMinuteOffset;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a font.
 */
@interface FSFont : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new font with given attribute.
 *
 * @param[in]	fontName		The typeface name of the font to be created. It should be in UTF-8 encoding.
 * @param[in]	fontStyles		Font styles.
 *								Please refer to {@link FS_FONTSTYLES::e_fontStyleFixedPitch FS_FONTSTYLES::e_fontStyleXXX} values
 *								and it can be one or a combination of these values.
 * @param[in]	weight			Original font weight. 0 means unspecified.
 * @param[in]	charset			The charset of the font to be created.
 *								Please refer to {@link FS_FONTCHARSET::e_fontCharsetANSI FS_FONTCHARSET::e_fontCharsetXXX} values
 *								and this should be one of these values.
 *
 * @return A new font object.
 */
+(FSFont*)create: (NSString*) fontName fontStyles: (unsigned int)fontStyles weight: (int)weight  charset: (enum FS_FONTCHARSET) charset;
/**
 * @brief	Create a new standard font by a standard font ID.
 *
 * @param[in]	fontID		Standard font ID of the font to be created.
 *							Please refer to {@link FS_STANDARDFONTID::e_fontStandardIDCourier FS_STANDARDFONTID::e_fontStandardIDXXX} values
 *
 * @return A new font object.If there is any error, this function will return <b>nil</b>.
 */
+(FSFont*)createStandard :(enum FS_STANDARDFONTID) fontID;
/**
 * @brief	Retrieve the face name.
 *
 * @return	The face name. It would be in UTF-8 encoding.
 */
-(NSString*) getName;
/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class for default appearance data, which is used for free text annotation.
 */
@interface FSDefaultAppearance :NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/**
 * @brief	Flags to indicate which properties of {@link ::FSDefaultAppearance} are meaningful.
 *
 * @details	Please refer to {@link FS_DEFAULTAPFLAGS::e_defaultAPFont FS_DEFAULTAPFLAGS::e_defaultAPXXX} values
 *			and this can be one or a combination of these values. 0 means no property of {@link ::FSDefaultAppearance} is meaningful.
 */
@property (nonatomic,assign) unsigned int flags;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FS_DEFAULTAPFLAGS::e_defaultAPFont})
 *			Font for default appearance. It should be a valid ::FSFont object when it is useful.
 */
@property (nonatomic,retain) FSFont* font;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FS_DEFAULTAPFLAGS::e_defaultAPFontSize})
 *			Font size for default appearance. It should be above 0 when it is useful.
 */
@property (nonatomic,assign) float fontSize;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FS_DEFAULTAPFLAGS::e_defaultAPTextColor})
 *			Text color for default appearance. Format: 0xAARRGGBB. Alpha value is ignored and will always be treated as 0xFF internally.
 */
@property (nonatomic,assign) unsigned int textColor;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** @brief Free the object. */

/**
 * @brief	Set value.
 *
 * @param[in]	flags		Flags to indicate which properties of {@link ::FSDefaultAppearance} are meaningful.
 *							Please refer to {@link FS_DEFAULTAPFLAGS::e_defaultAPFont FS_DEFAULTAPFLAGS::e_defaultAPXXX} values
 *							and this can be one or a combination of these values.
 * @param[in]	font		Font for default appearance. Please ensure this is a valid {@link ::FSFont} object when parameter <i>flags</i> includes {@link 
 *                                  FS_DEFAULTAPFLAGS::e_defaultAPFont}.
 * @param[in]	fontSize	Font size for default appearance. Please ensure this is above 0 when parameter <i>flags</i> includes {@link FS_DEFAULTAPFLAGS::e_defaultAPFontSize}.
 * @param[in]	textColor	Text color for default appearance. Format: 0xAARRGGBB. Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) set: (unsigned int) flags font: (FSFont*) font fontSize: (float)fontSize textColor: (unsigned int) textColor;
/** @brief Initialize the object. */
-(id)init;
/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to represent a PDF path.
 *
 * @details	A PDF path can contain more than one figure.
 */
@interface FSPDFPath : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new PDF path object.
 *
 * @return	A new empty PDF path object.
 *			If there is any error, this function will return <b>nil</b>.
 */
+(FSPDFPath*) create;
/**
 * @brief	Get the count of points.
 *
 * @return	The count of points.
 */
-(int)getPointCount;
/**
 * @brief	Get a point specified by index.
 *
 * @param[in]	index	The index of the point. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	The specified point.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*) getPoint : (int)index;
/**
 * @brief	Get the type of a point specified by index.
 *
 * @param[in]	index	The index of the point. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	The type of specified point.
 *			Please refer to {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo FS_PATHPOINTTYPE::e_pointTypeXXX} values and it would be one of them.
 *			If an error occurs, this function will return 0.
 */
-(enum FS_PATHPOINTTYPE)getPointType : (int) index;
/**
 * @brief	Change the value and type of a point specified by index.
 *
 * @param[in]	index			The index of the point. Valid range: 0 to (<i>count</i>-1).<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 * @param[in]	point			The point to set, in PDF coordinate system.
 * @param[in]	pointType		The type used to set to the point.
 *								Please refer to {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo FS_PATHPOINTTYPE::e_pointTypeXXX} values
 *								and it should be one of them.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPoint: (int)index  point: (FSPointF*)point pointType: (enum FS_PATHPOINTTYPE)pointType;
/**
 * @brief	Add a point to the end of current PDF path, to start a new figure.
 *
 * @details	If this funtion succeeds, the new point will become the new "current point",
 *			and the new figure will become the new "current figure".
 *
 * @param[in]	point	New point, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)moveTo : (FSPointF*) point;
/**
 * @brief	Add a point to the end of current figure, and a line is to be drawn from current point to the new point.
 *
 * @details	If this function succeeds, the new point will become the new "current point".
 *
 * @param[in]	point	New point, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)lineTo : (FSPointF*) point;
/**
 * @brief	Add a cubic bezier spline to the end of current figure, by three points: two control points and one target point.
 *
 * @details	If this function succeeds, parameter <i>point3</i> will become the new "current point".
 *
 * @param[in]	point1		New point as the first control point for cubic bezier, in PDF coordinate system.
 * @param[in]	point2		New point as the second control point for cubic bezier, in PDF coordinate system.
 * @param[in]	point3		New point as target point for cubic bezier, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)cubicBezierTo: (FSPointF*)point1  point2: (FSPointF*)point2  point3: (FSPointF*)point3;
/**
 * @brief	Close current figure (which is also the last figure in current PDF path).
 *
 * @details	When closing current figure, the last point's type may be changed:
 *			<ul>
 *			<li>If the last point's type is {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo}, that means the last figure just has one point and cannot be closed
 *				and current function will return <b>FALSE</b>.</li>
 *			<li>If the last point's type is {@link FS_PATHPOINTTYPE::e_pointTypeLineTo}, the type will be changed to {@link FS_PATHPOINTTYPE::e_pointTypeLineToCloseFigure}.</li>
 *			<li>If the last point's type is {@link FS_PATHPOINTTYPE::e_pointTypeLineTo}, the type will be changed to {@link FS_PATHPOINTTYPE::e_pointTypeBezierToCloseFigure}.</li>
 *			<li>If the last point's type is already {@link FS_PATHPOINTTYPE::e_pointTypeLineToCloseFigure} or {@link FS_PATHPOINTTYPE::e_pointTypeBezierToCloseFigure},
 *				that means the last figure has been closed. The type will not be changed and function will still return <b>YES</b>.</li>
 *			</ul>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)closeFigure;
/**
 * @brief	Remove a point specified by index.
 *
 * @param[in]	index	The index of the point to be removed. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removePoint : (int)index;
/**
 * @brief	Clear all points.
 */
-(void) clear;
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a callback object to do file reading.
 * 
 * @details	All the functions in this class are used as callback functions 
 *			and should be implemented by user, to do file reading in a customized way.
 */
@interface FSFileReadCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Required callback function used to get the total size of the file.
 *
 * @return	The file size, in bytes. 
 *			If any error occurs, implementation of this function should return 0.
 */
-(unsigned long long)getSize;
/**
 * @brief	Required callback function used to read a data block from the file.
 *
 * @param[in]	offset			Byte offset from the beginning of the file.
 * @param[in]	size			The number of bytes for the block.
 *
 * @return	A data block from the file.
 *			If any error occurs, implementation of this function should return <b>nil</b>.
 */
-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size;

/** @brief Free the object. */
-(void)dealloc;

@end

 /**
 * @brief	Class to represent a callback object to do pause control in progressive process.
 * 
 * @details	All the functions in this class are used as callback functions and should be implemented by user.<br>
 * 			Usually, this is used for a process that may take a long time, such as rendering process, PDF page parsing process, 
 *			PDF searching process, and so on.
 */
@interface FSPauseCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to decide whether current process needs to pause or not.
 *
 * @details	During a process, which may takes long time, Foxit PDF SDK will call this function several times to check whether application wants to pause the process or not.
 *			Usually, caller can use a timer to determine how long at most should wait before pause.
 *
 * @return	<b>YES</b> means the process needs to be paused, while <b>NO</b> means the process can continue to run without being paused.
 */
-(BOOL)needPauseNow;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for action type.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ACTIONTYPE {
	/** @brief	Action type: unknown action. */
	e_actionTypeUnknown = 0,
	/** @brief	Action type: go-to action. */
	e_actionTypeGoto = 1,
	/** @brief	Action type: remote go-to action. */
	e_actionTypeGoToR = 2,
	/** @brief	Action type: embedded go-to action. */
	e_actionTypeGoToE = 3,
	/** @brief	Action type: launch action. */
	e_actionTypeLaunch = 4,
	/** @brief	Action type: thread action. */
	e_actionTypeThread = 5,
	/** @brief	Action type: uniform resource identifier (URI) action. */
	e_actionTypeURI = 6,
	/** @brief	Action type: sound action. */
	e_actionTypeSound = 7,
	/** @brief	Action type: movie action. */
	e_actionTypeMovie = 8,
	/** @brief	Action type: hide action. */
	e_actionTypeHide = 9,
	/** @brief	Action type: named action. */
	e_actionTypeNamed = 10,
	/** @brief	Action type: submit-form action. */
	e_actionTypeSubmitForm = 11,
	/** @brief	Action type: reset-form action. */
	e_actionTypeResetForm = 12,
	/** @brief	Action type: import-data action. */
	e_actionTypeImportData = 13,
	/** @brief	Action type: JavaScript action. */
	e_actionTypeJavaScript = 14,
	/** @brief	Action type: set-OCG-state action. */
	e_actionTypeSetOCGState = 15,
	/** @brief	Action type: rendition action. */
	e_actionTypeRendition = 16,
	/** @brief	Action type: transition action. */
	e_actionTypeTrans = 17,
	/** @brief	Action type: go-to-3D-view action. */
	e_actionTypeGoTo3DView = 18
};

/**
 * @brief	Class to represent destination information.
 *
 * @details	A destination defines a particular view of a PDF document, consisting of the following items:
 *			<ul>
 *			<li>The page of the document to be displayed.</li>
 *			<li>The location of the document window on that page.</li>
 *			<li>The magnification (zoom) factor to use when displaying the page.</li>
 *			</ul>
 *			Destinations may be associated with bookmarks, link annotations, or some types of actions.
 *			In each case, the destination specifies the view of the document to be presented when the bookmark 
 *			item or link annotation is opened or the action is performed.<br>
 *			This class offers functions to create destination objects for different zoom mode, and get destination data.
 *
 * @see FSBookmark
 * @see FSLink
 * @see FSGotoAction
 */
@interface FSDestination : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomXYZ}.
 *
 * @param[in]	page			The destination page.
 * @param[in]	left			Horizontal coordinate value of a position as page's left-top position.
 * @param[in]	top				Vertical coordinate value of a position as page's left-top position.
 * @param[in]	zoomFactor		Zoom factor value.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createXYZ: (FSPDFPage*)page left: (float)left top: (float)top zoomFactor: (float)zoomFactor;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitPage}.
 *
 * @param[in]	page	The destination page.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitPage: (FSPDFPage*)page;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitHorz}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	top		Vertical coordinate of top edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitHorz: (FSPDFPage*)page top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitVert}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	left	Horizontal coordinate of left edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitVert: (FSPDFPage*)page left: (float)left;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitRect}.
 *
 * @param[in]	page		The destination page.
 * @param[in]	left		The coordinate left of a rectangle.
 * @param[in]	bottom		The coordinate bottom of a rectangle.
 * @param[in]	right		The coordinate right of a rectangle.
 * @param[in]	top			The coordinate top of a rectangle.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitRect: (FSPDFPage*)page left: (float)left bottom: (float)bottom right: (float)right top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBBox}.
 *
 * @param[in]	page		The destination page.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBBox: (FSPDFPage*)page;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBHorz}.
 *
 * @param[in]	page		The destination page.
 * @param[in]	top			Vertical coordinate of top edge
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBHorz: (FSPDFPage*)page top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBVert}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	left	Horizontal coordinate of left edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBVert: (FSPDFPage*)page left: (float)left;
/** 
 * @brief	Get the index of the destination page.
 * 
 * @return	The page index, starting from 0.
 *			If there is any error, this function will return -1.
 */
-(int)getPageIndex;
/**
 * @brief	Get the zoom mode
 *
 * @return	Zoom mode value. Please refer to {@link FS_ZOOMMODE::e_zoomXYZ FS_ZOOMMODE::e_zoomXXX} values and it would be one of them.
 *			If there is any error, this function will return 0.
 */
-(enum FS_ZOOMMODE)getZoomMode;
/**
 * @brief	Get left position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}, {@link FS_ZOOMMODE::e_zoomFitVert}, {@link FS_ZOOMMODE::e_zoomFitRect} or {@link FS_ZOOMMODE::e_zoomFitBVert}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The left position value.
 */
-(float)getLeft;
/**
 * @brief	Get top position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}, {@link FS_ZOOMMODE::e_zoomFitHorz}, {@link FS_ZOOMMODE::e_zoomFitBHorz} or {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The top position value.
 */
-(float)getTop;
/**
 * @brief	Get right position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The right position value.
 */
-(float)getRight;
/**
 * @brief	Get bottom position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The bottom position value.
 */
-(float)getBottom;
/**
 * @brief	Get zoom factor.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The zoom factor.
 */
-(float)getZoomFactor;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a PDF action.
 *
 * @details	PDF supports following standard action types:<br>
 *			"Go-To Action", "Remote Go-To Action", "Embedded Go-To Action", "Launch Action", "Thread Action",
 *			"URI Action", "Sound Action", "Movie Action", "Hide Action", "Named Action", "Submit-Form Action",
 *			"Reset-Form Action", "Import-Data Action", "JavaScript Action", "Set-OCG-State Action", "Rendition Action",
 *			"Transition Action", "Go-To-3D-View Action".<br>
 *			A PDF action may have sub-actions. When this action is triggered, its sub-actions should also be triggered in turn.<br>
 *			Class ::FSAction is the base class for all kinds of PDF actions. For concrete action types, please refer to derived classes.
 *			Function {@link FSLink::getAction} can be used to get an action from a link annotation.
 *			Function {@link FSAction::create:actType:} can be used to create a new action -- currently only support {@link FS_ACTIONTYPE::e_actionTypeGoto}, and {@link FS_ACTIONTYPE::e_actionTypeURI}.
 *			This class also offers functions to access sub-actions.
 *
 * @see	FSLink
 */
@interface FSAction : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new empty action, with specified action type.
 *
 * @details	The newly created action has no action data (except action type) yet.
 *			User needs to call the methods in concrete action classes to set action data.
 *
 * @param[in]	doc		The PDF document, which the new action belongs to. It should be valid.
 * @param[in]	actType		Action type, used to specify which action is to be created.
 *							Currently only support:<br>
 *							{@link FS_ACTIONTYPE::e_actionTypeGoto}, {@link FS_ACTIONTYPE::e_actionTypeURI}.
 *
 * @return	A new action object, with no action data.
 *			If there is any error, this function will return <b>nil</b>.
 */
+(FSAction*) create :(FSPDFDoc*)doc   actType:(enum FS_ACTIONTYPE) actType;
/**
 * @brief	Get action type.
 *
 * @return	Action type. Please refer to {@link FS_ACTIONTYPE::e_actionTypeGoto FS_ACTIONTYPE::e_actionTypeXXX} values and it would be one of them.
 */
-(enum FS_ACTIONTYPE)getType;
/**
 * @brief	Get the count of sub-actions.
 *
 * @return	The count of sub-actions.
 */
-(int)getSubActionCount;
/**
 * @brief	Get the sub-actions by index.
 *
 * @param[in]	index	 Index of sub-action to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSAction::getSubActionCount}.
 *
 * @return	A action instance for sub-action.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSAction*)getSubAction: (int)index;
/**
 * @brief	Set the sub-action by index.
 *
 * @param[in]	index	 Index of sub-action to be retrieved. Valid range: from 0 to (<i>count</i>-1).<i>count</i> is returned by function {@link FSAction::getSubActionCount}.
 * @param[in]	subAction	New sub-action to be set.
 *							Currently only support following types as the new sub-action:<br>
 *							{@link FS_ACTIONTYPE::e_actionTypeGoto}, {@link FS_ACTIONTYPE::e_actionTypeURI}.
 */
-(void)setSubAction : (int)index  subAction:(FSAction*)subAction;
/**
 * @brief	Insert a new sub-action to the location specified by index.
 *
 * @param[in]	index	 Index of the location, where the new sub-action is inserted. <br>
 *							If this index value is below zero, the new sub-action will be inserted to be the first.<br>
 *							If this index value equals or larger than current sub-action count, the new sub-action will be inserted to be the last.
 * @param[in]	subAction	New sub-action to be inserted.
 *							Currently only support following types as the new sub-action:<br>
 *							{@link FS_ACTIONTYPE::e_actionTypeGoto}, {@link FS_ACTIONTYPE::e_actionTypeURI}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)insertSubAction :(int)index  subAction:(FSAction*)subAction;

/**
 * @brief	Remove a sub-action, specified by index.
 *
 * @param[in]	index 	Index of sub-action to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSAction::getSubActionCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeSubAction : (int)index;

/**
 * @brief	Remove all the sub-actions.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAllSubActions;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a go-to action.
 *
 * @details	Go-to action is an action that changes the view to a specified destination (page, location, and magnification factor).<br>
 *			Class ::FSGotoAction is derived from ::FSAction and offers functions to access go-to action data.
 *
 * @see FSAction
 */
@interface FSGotoAction : FSAction
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the destination which the action will jump to.
 *
 * @return	A destination instance object. 
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSDestination*)getDestination;
/**
 * @brief	Set the destination information.
 *
 * @param[in]	dest	New destination object to be set.
 */
-(void)setDestination : (FSDestination*)dest;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a uniform resource identifier (URI) action.
 *
 * @details	URI action is an action that causes a URI to be resolved.
 *			Class ::FSURIAction is derived from ::FSAction and offers functions to access URI action data.
 *
 * @see FSAction
 */
@interface FSURIAction : FSAction
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the URI string.
 *
 * @return	URI string.
 */
-(NSString *)getURI;
/**
 * @brief	Set the URI string.
 *
 * @param[in]	uri		New URI string to be set.
 */
-(void)setURI : (NSString*)uri;

/**
 * @brief	Set the value for tracking position flag.
 *
 * @param[in]	isTrackPosition		New boolean value to be set:<br>
 *									<b>YES</b> means to track position, while <b>NO</b> means not to track position.
 */
-(void)setTrackPositionFlag : (BOOL)isTrackPosition;
/**
 * @brief	Check whether to track the mouse position when the URI is resolved.
 *
 * @return	<b>YES</b> means application should track the mouse position,
 *			while <b>NO</b> means no need to track the mouse position.
 */
-(BOOL)isTrackPosition;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** 
 * @brief	Enumeration for PDF annotation type.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ANNOTTYPE {
	/** @brief	Annotation type: unknown.*/
	 e_annotUnknownType= 0,
	/** @brief	Annotation type: note annotation, which is just "Text" annotation defined in <PDF reference 1.7>.*/
	 e_annotNote		= 1,
	/** @brief	Annotation type: link annotation.*/
	 e_annotLink		= 2,
	/** @brief	Annotation type: free text annotation.*/
	 e_annotFreeText	= 3,
	/** @brief	Annotation type: line annotation.*/
	 e_annotLine		= 4,
	/** @brief	Annotation type: square annotation.*/
	 e_annotSquare	= 5,
	/** @brief	Annotation type: circle annotation.*/
	 e_annotCircle	= 6,
	/** @brief	Annotation type: polygon annotation.*/
	 e_annotPolygon	= 7,
	/** @brief	Annotation type: polyline annotation.*/
	 e_annotPolyLine	= 8,
	/** @brief	Annotation type: highlight annotation.*/
	 e_annotHighlight= 9,
	/** @brief	Annotation type: underline annotation.*/
	 e_annotUnderline= 10,
	/** @brief	Annotation type: squiggly annotation.*/
	 e_annotSquiggly	= 11,
	/** @brief	Annotation type: strikeout annotation.*/
	 e_annotStrikeOut= 12,
	/** @brief	Annotation type: stamp annotation.*/
	 e_annotStamp	= 13,
	/** @brief	Annotation type: caret annotation.*/
	 e_annotCaret	= 14,
	/** @brief	Annotation type: ink annotation.*/
	 e_annotInk		= 15,
	/** @brief	Annotation type: pressure sensitive ink annotation.*/
	 e_annotPSInk	= 16,
	/** @brief	Annotation type: file attachment annotation.*/
	 e_annotFileAttachment		= 17,
	/** @brief	Annotation type: sound annotation.*/
	 e_annotSound	= 18,
	/** @brief	Annotation type: movie annotation.*/
	 e_annotMovie	= 19,
	/** @brief	Annotation type: widget annotation.*/
	 e_annotWidget	= 20,
	/** @brief	Annotation type: screen annotation.*/
	 e_annotScreen	= 21,
	/** @brief	Annotation type: printer's mark annotation.*/
	 e_annotPrinterMark= 22,
	/** @brief	Annotation type: trap network annotation.*/
	 e_annotTrapNet	= 23,
	/** @brief	Annotation type: watermark annotation.*/
	 e_annotWatermark= 24,
	/** @brief	Annotation type: 3D annotation.*/
	 e_annot3D		= 25,
	/** @brief	Annotation type: pop-up annotation.*/
	 e_annotPopup	= 26
};

/** 
 * @brief	Enumeration for PDF annotation flags.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_ANNOTFLAGS {
	/** @brief	Annotation flag: invisible */
	e_annotFlagInvisible = 0x0001,
	/** @brief	Annotation flag: hidden */
	e_annotFlagHidden = 0x0002,
	/** @brief	Annotation flag: print */
	e_annotFlagPrint = 0x0004,
	/** @brief	Annotation flag: no zoom */
	e_annotFlagNoZoom = 0x0008,
	/** @brief	Annotation flag: no rotate */
	e_annotFlagNoRotate = 0x0010,
	/** @brief	Annotation flag: no view */
	e_annotFlagNoView = 0x0020,
	/** @brief	Annotation flag: read only */
	e_annotFlagReadOnly = 0x0040,
	/** @brief	Annotation flag: locked */
	e_annotFlagLocked = 0x0080,
	/** @brief	Annotation flag: toggle no view */
	e_annotFlagToggleNoView = 0x0100,
	/** @brief	Annotation flag: locked contents */
	e_annotFlagLockedContents = 0x0200
};

/** 
 * @brief	Enumeration for PDF annotation border style.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_BORDERSTYLE {
	/** @brief	Border style: Solid */ 
	 e_borderStyleSolid		= 0,
	/** 
	 * @brief	Border style: Dashed. 
	 *
	 * @details	This is only useful for link, free text, line, square, circle, polygon, and polyline annotation. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleDashed	= 1,
	/** 
	 * @brief	Border style: Underline.
	 *
	 * @details	This is only useful for link annotation. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleUnderLine	= 2,
	/** 
	 * @brief	Border style: Beveled. 
	 *
	 * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
	 *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleBeveled	= 3,
	/** 
	 * @brief	Border style: Inset.
	 *
	 * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
	 *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleInset		= 4,
	/** 
	 * @brief	Border style: Cloudy. 
	 *
	 * @details	This is only useful for free text, square, circle, and polygon annotations. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleCloudy	= 5
};

/** 
 * @brief	Enumeration for PDF annotation highlighting mode.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_HIGHLIGHTINGMODE {
	/** @brief	Highlighting mode: None. */
	 e_highlightingModeNone			= 0 ,
	/** @brief	Highlighting mode: Invert */
	 e_highlightingModeInvert		= 1 ,
	/** @brief	Highlighting mode: Outline */
	 e_highlightingModeOutline		= 2 ,
	/** @brief	Highlighting mode: Push */
	 e_highlightingModePush			= 3 ,
	/** @brief	Highlighting mode: Toggle. This is only useful for widget annotation. */
	 e_highlightingModeToggle		= 4
};

/**
 * @brief	Class to access a PDF annotation.
 *
 * @details	An annotation associates an object such as a note, sound, or movie with a location
 *			on a page of a PDF document, or provides a way to interact with the user by
 *			means of the mouse and keyboard. PDF includes a wide variety of standard annotation types.<br>
 *			Class ::FSAnnot is the base class for all kinds of PDF annotations. It offers the base functions
 *			to access annotation's common properties, to move an annotation or reset appearance stream of an annotation.
 *			For concrete annotation types, please refer to derived classes.
 *			To get the count of annotations or get/add/remove an annotation, please refer to class ::FSPDFPage.<br>
 *			Specially, for widget annotation, Foxit PDF SDK treats it as a form control, so the drived class for widget annot is class ::FSFormControl.<br>
 *
 * @note	Currently, following kind of functions only support note, highlight, underline, strikeout, squiggly, link,
 *			square, circle, free text, stamp, caret, ink, line, polygon, polyline, file attachment, popup, widget annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSAnnot.</li>
 *			<li>2. Functions {@link FSAnnot::move:}, {@link FSAnnot::resetAppearanceStream}, {@link FSAnnot::removeProperty:}.
 *				   Specially, when the widget annotatoin represents as a signature field, {@link FSAnnot::resetAppearanceStream} does not support it.
 *			</li>
 *			</ul>
 *
 * @see	FSPDFPage
 * @see	FSFormControl
 */
@interface FSAnnot : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the related PDF page.
 * 
 * @return	The related PDF page instance.
 *			Do not call function {@link FSPDFDoc::closePage:} for the returned page instance.
 */
-(FSPDFPage*)getPage;
/**
 * @brief	Check if current annotation is a markup annotation.
 *
 * @return	<b>YES</b> means current annotation is a markup annotation, while <b>NO</b> means current annotation is not a markup annotation.
 */
-(BOOL)isMarkup;
/**
 * @brief	Get actual annotation type of current annotation.
 *
 * @return	Annotation type.
 *			Please refer to {@link FS_ANNOTTYPE::e_annotNote FS_ANNOTTYPE::e_annotXXX} values and it would be one of these values.
 */
-(enum FS_ANNOTTYPE)getType;
/**
 * @brief	Get the index of current annotation, in the page which current annotation belongs to.
 *
 * @return	The index value, starting from 0. 
 *			If there is any error, -1 would be returned.
 */
-(int)getIndex;
/**
 * @brief	Get content.
 *
 * @return	Content string.
 */
-(NSString *)getContent;
/**
 * @brief	Set content.
 *
 * @param[in]	content		New content string to be set.
 */
-(void)setContent: (NSString *)content;
/**
 * @brief	Get last modification date time.
 *
 * @return	A date time instance that receives the last modified date time.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set last modification date time.
 *
 * @param[in]	dataTime		The data time to be set. It should contain valid date time data.
 */
-(void)setModifiedDateTime: (FSDateTime*)dataTime;
/**
 * @brief	Get annotation flags.
 *
 * @return	The annotation flags. 
 *			Please refer to {@link FS_ANNOTFLAGS::e_annotFlagInvisible FS_ANNOTFLAGS::e_annotFlagXXX} values and it would be one or a combination of them.
 *			0 means no annotation flag.
 */
-(unsigned int)getFlags;
/**
 * @brief	Set annotation flags.
 *
 * @param[in]	flags	The annotation flags. 
 *						It could be 0, or one or a combination of {@link FS_ANNOTFLAGS::e_annotFlagInvisible FS_ANNOTFLAGS::e_annotFlagXXX} values.
 */
-(void)setFlags: (unsigned int)flags;
/**
 * @brief	Get unique ID.
 *
 * @return	Unique ID string.
 */
-(NSString *)getUniqueID;
/**
 * @brief	Set unique ID.
 *
 * @param[in]	uniqueID		New unique ID string to be set.
 */
-(void)setUniqueID: (NSString *)uniqueID;
/** 
 * @brief	Get rectangle, in PDF coordinate system.
 *
 * @return	Annotation's rectangle, in PDF coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectF*)getRect;
/** 
 * @brief	Move current annotation to a new position, specified by a new rectangle in PDF coordinate system.
 *
 * @param[in]	rect	New rectangle to specify the new position where current annotation is to be moved to.
 *						It should be valid in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)move: (FSRectF*)rect;
/** 
 * @brief	Get border information.
 *
 * @details	For an annotation which does not have border information, the default border information will be returned:<br>
 *			width of {@link FSBorderInfo} is 1, style of {@link FSBorderInfo} is {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			intensity of {@link FSBorderInfo} is -1, dashPhase of {@link FSBorderInfo} is 0, 
 *			dashes array of {@link FSBorderInfo} is <b>nil</b>.
 *
 * @return	A ::FSBorderInfo object that received the border information.
 *			If not find any border information, the default border information would be returned as described in "Details" part.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSBorderInfo*)getBorderInfo;
/** 
 * @brief	Set border information.
 *
 * @param[in]	border		New border information to be set. Values of border information should be valid.<br>
 *							If any value of parameter <i>border</i> is invalid, this function will fail to set new border information to current annotation.
 */
-(void)setBorderInfo: (FSBorderInfo*)border;
/**
 * @brief	Get border color.
 *
 * @return	The border color. Format: 0xAARRGGBB. 
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no border color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getBorderColor;
/**
 * @brief	Set border color.
 * 
 * @param[in]	color		New border color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setBorderColor: (unsigned int)color;
/** 
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get annotation rectangle in device coordinate system.
 *
 * @details	This is a useful function to get the device rectangle of an annotation, but not support pop-up annotation.<br>
 *			For the rectangle conversion, the result rectangle is always "normalized",
 *			which is based on device coordinate system: left is always smaller than right, and top is always smaller than bottom.
 *
 * @param[in]	isTransformIcon	A boolean value which indicates that whether to transform (like rotate or scale) the icon with page:
 *								<b>YES</b> means to transform icon's rectangle with page,
 *								while <b>NO</b> means not transform icon's rectangle with page.<br>
 *								This parameter only affects on "Text" and "FileAttachment" annotations, because they are shown as icon.
 * @param[in]	matrix			A matrix used to transform from PDF coordinate system to device coordinate system.
 *								Usually, this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:} and also used for rendering.
 *
 * @return	A rectangle in device coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectI*)getDeviceRect: (BOOL)isTransformIcon matrix: (FSMatrix*)matrix;
/** 
 * @brief	Get annotation's dictionary.
 *
 * @return	Annotation's dictionary.
 */
-(FSPDFDictionary*)getDict;
/**
 * @brief	Remove a specified annotation's property.
 *
 * @details	This function can be used to remove some optional properties of an annotation.
 *
 * @param[in]	property	Property name. Please refer to {@link FSM_ANNOTPROPERTY::e_annotPropertyModifiedDate FSM_ANNOTPROPERTY::e_annotPropertyXXX} values
 *							and it should be one of these values.
 *
 * @return	<b>YES</b> means remove the specified property successfully, or current annotation supports the property but does not have the property.
 *			<b>NO</b> means current annotation does not support to have the specified property, current annotation cannot be modified or failure.
 */
-(BOOL)removeProperty: (enum FS_ANNOTPROPERTY)property;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent annotation border information.
 *
 * @details	This class offers functions to access PDF annotation border information,
 *			such as border width, border style and so on.
 *			This class is used for functions {@link FSAnnot::getBorderInfo} and {@link FSAnnot::setBorderInfo:}.
 *
 * @see FSAnnot
 */
@interface FSBorderInfo : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	width		Border width, in points. This should be a non-negative value.
 *							If this value is 0, no border is drawn.
 * @param[in]	style		Border style. Please refer to {@link FSM_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} values and it should be one of these values.
 * @param[in]	intensity	Intensity of the cloudy effect. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleCloudy}.
 *							Valid value range: 0 to 2. 0 means no cloudy border effect.<br>
 *							If the value is below 0, it will have the same effect as value 0.
 *							If the value is above 2, it will have the same effect as value 2.
 * @param[in]	dashPhase	Dash phase. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 * @param[in]	dashes	Dashes array. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleDashed}.<br>
 *							The value of useful elements in this array should not be negative.<br>
 *							In this array, an element with value -1 means that all the elements before this element are useful,
 *							and this element with the rest will be ignored.<br>
 *							If no element's value is -1, that means all of 16 elements are useful.
 */
-(void)set: (float)width style: (enum FS_BORDERSTYLE)style intensity: (float)intensity dashPhase: (float)dashPhase dashes: (NSArray *)dashes;
/**
 * @brief	Set border width, in points.
 *
 * @param[in]	value	Border width. This value should not be negative. 
 *						If this value is 0, no border will be drawn.
 */
-(void)setWidth: (float)value;
/**
 * @brief	Get border width, in points.
 *
 * @return	Border width. It would be non-negative.
 *			0 means no border will be drawn. 
 */
-(float)getWidth;
/** 
 * @brief	Set border style. 
 *
 * @param[in]	value	Border style.
 *						Please refer to enumeration {@link FS_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} and this should be one of its values.
 *						Please also check comment of these values for more details.
 */
-(void)setStyle: (enum FS_BORDERSTYLE)value;
/** 
 * @brief	Get border style. 
 *
 * @return	Border style.
 *			Please refer to enumeration {@link FS_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} and this should be one of its values.
 */
-(enum FS_BORDERSTYLE)getStyle;
/**
 * @brief	set intensity of the cloudy effect.
 *
 * @details	This is only useful to free text, square, circle, polygon, and polyline annotations
 *			when FSBorderInfo::Style is {@link FSM_BORDERSTYLE::e_borderStyleCloudy}.<br>
 *			Suggested value range: 0 to 2. 0 means no cloudy border effect. <br>
 *			For rest value, their effect would be:
 *			<ul>
 *			<li>If the value is below 0, it will have the same effect as value 0. </li>
 *			<li>If the value is above 2, it will have the same effect as value 2.</li>
 *			</ul>
 * @param[in]	value	Intensity of the cloudy effect. Valid value range: 0 to 2.
 *						-1 mean no cloudy border effect.<br>
 */
-(void)setCloudIntensity: (float)value;
/** 
 * @brief	Get intensity of the cloudy effect. 
 *
 * @details	Intensity of the cloudy effect is only useful to free text, square, circle, polygon, and polyline annotations 
 *			when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleCloudy}.
 *
 * @return	Intensity of the cloudy effect. Valid value range: 0 to 2. 
 *			-1 mean no cloudy border effect.<br>
 */
-(float)getCloudIntensity;
/** 
 * @brief	Set dash phase. 
 *
 * @details	Dash phase is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *             The value of useful elements in this array should not be negative.<br>
 *			In this array, an element with integer value -1 means that all the elements before this element are useful,
 *			and this element with the rest will be ignored.<br>
 *			If no element's value is -1, that means all of 16 elements are useful.
 *
 * @param[in]	value	New dash phase.
 */
-(void)setDashPhase: (float)value;
/**
 * @brief	Get dash phase.
 *
 * @details	Dash phase is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @return	Dash phase.
 */
-(float)getDashPhase;
/**
 * @brief	Set dash pattern array.
 *
 * @details	Dashes array is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @param[in]	value	New dash pattern array, with float values.
 *						Only the first 16 elements will be used and all the useful elements in this array should be non-negative float value.<br>
 *						<b>nil</b> means no dash pattern array is needed.
 */
-(void)setDashes: (NSArray *)value;
/**
 * @brief	Get dash pattern array.
 *
 * @details	Dashes array is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @return	Dashes array, with at most 16 valid float values.
 *			<b>nil</b> means no dash pattern array.
 */
-(NSArray *)getDashes;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a quadrilateral, in PDF coordinate system.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *			This class offers functions to access points values of a quadrilateral.
 */
@interface FSQuadPoints : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	first		First point of the quadrilateral, in PDF coordinate system.
 * @param[in]	second		Second point of the quadrilateral, in PDF coordinate system.
 * @param[in]	third		Third point of the quadrilateral, in PDF coordinate system.
 * @param[in]	fourth		Fourth point of the quadrilateral, in PDF coordinate system.
 */
-(void)set: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth;
/** 
 * @brief	Set first point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	First point to be set.
 */
-(void)setFirst: (FSPointF*)value;
/** 
 * @brief	Get first point of quadrilateral, in PDF coordinate system.
 *
 * @return	First point value.
 */
-(FSPointF*)getFirst;
/** 
 * @brief	Set second point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Second point to be set.
 */
-(void)setSecond: (FSPointF*)value;
/** 
 * @brief	Get second point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Second point value.
 */
-(FSPointF*)getSecond;
/** 
 * @brief	Set third point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Third point to be set.
 */
-(void)setThird: (FSPointF*)value;
/** 
 * @brief	Get third point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Third point value.
 */
-(FSPointF*)getThird;
/** 
 * @brief	Set fourth point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Fourth point to be set.
 */
-(void)setFourth: (FSPointF*)value;
/** 
 * @brief	Get fourth point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Fourth point value.
 */
-(FSPointF*)getFourth;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent shading color.
 *
 * @details	This class represents colors used for Type 2 (Axial) Shadings. 
 *			It offers functions to access the 2 colors used for Type 2 (Axial) Shadings. 
 */
@interface FSShadingColor : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	firstColor		First color used for shading. Format: 0xAARRGGBB.
 * @param[in]	secondColor		Second color used for shading. Format: 0xAARRGGBB.
 */
-(void)set: (unsigned int)firstColor secondColor: (unsigned int)secondColor;
/** 
 * @brief	Set first color used for shading. 
 *
 * @param[in]	value	First color to be set. Format: 0xAARRGGBB.
 */
-(void)setFirstColor: (unsigned int)value;
/** 
 * @brief	Get first color used for shading. 
 *
 * @return	First color. Format: 0xAARRGGBB. 
 */
-(unsigned int)getFirstColor;
/** 
 * @brief	Set second color used for shading. 
 *
 * @param[in]	value	Second color to be set. Format: 0xAARRGGBB.
 */
-(void)setSecondColor: (unsigned int)value;
/** 
 * @brief	Get second color used for shading. 
 *
 * @return	Second color. Format: 0xAARRGGBB. 
 */
-(unsigned int)getSecondColor;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to represent a callback object as customized annotation icon provider.
 * 
 * @details	All the functions int this class are used as callback functions and should be implemented by user.
 *			Icon provider can only be used for note, file attachment, stamp annotations.
 *			Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers
 *			by callback functions {@link FSAnnotIconProviderCallback::getProviderID} and {@link FSAnnotIconProviderCallback::getProviderVersion}.
 */
@interface FSAnnotIconProviderCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to get provider ID. 
 *
 * @details	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers.
 *
 * @return	The provider ID string.
 */
-(NSString *)getProviderID;
/**
 * @brief	A callback function used to get provider version. 
 *
 * @details	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers.
 *
 * @return	Version string.
 */
-(NSString *)getProviderVersion;
/** 
 * @brief	A callback function used to check if current icon provider supports icon for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports the specific icon, 
 *			while <b>NO</b> means not support.
 */
-(BOOL)hasIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to check if current icon provider supports to change color for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports to change color for a specific icon type, 
 *			while <b>NO</b> means not support.
 */
-(BOOL)canChangeColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to get the icon as PDF page contents for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	color		The annotation icon color. Format: 0xAARRGGBB. 
 *
 * @return	A page instance, whose content would be used as the icon.
 */
-(FSPDFPage*)getIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName color: (unsigned int)color;
/** 
 * @brief	A callback function used to get the shading colors if current icon provider supports for a specified type.
 *			Currently, only support Type-2 shading settings with two color values.
 *
 * @param[in]	annotType		The annotation type.
 *								It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName		The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	refColor		Referenced color. Format: 0xAARRGGBB and alpha component is ignored.
 * @param[in]	shadingIndex	Index color of shading, starting from 0. If shading colors are more than one, this function will be called multiple times.
 *
 * @return	The two shading color value.
 *			If there is any error, implementation of this function should return <b>nil</b>.
 */
-(FSShadingColor*)getShadingColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName refColor: (unsigned int)refColor shadingIndex: (int)shadingIndex;
/** 
 * @brief	A callback function used to get the width for display of a specified icon, in device size(pixel normally).
 *
 * @details	This can be triggered during rendering process only when 
 *			function {@link FSRenderer::setTransformAnnotIcon:} is called with value <b>NO</b> before rendering.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The width for display.
 */
-(NSNumber*)getDisplayWidth: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to get the height for display of a specific icon, in device size(pixel normally).
 *
 * @details	This can be triggered during rendering process only when 
 *			function {@link FSRenderer::setTransformAnnotIcon:} is called with value <b>NO</b> before rendering.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The height for display.
 */
-(NSNumber*)getDisplayHeight: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a caret annotation.
 *
 * @details	A pop-up annotation (PDF 1.3) displays text in a pop-up window for entry and editing.
 *			It typically does not appear alone but is associated with a markup annotation, its parent annotation, and is used for editing the parent's text. <br>
 *			It has no appearance stream or associated actions of its own, so function {@link FSAnnot::resetAppearanceStream} will always return <b>FALSE</b> for a pop-up annotation.
 *			Class ::FSPopup is derived from class ::FSAnnot and also offers functions to access pop-up annotation's properties.
 *
 * @see	FSAnnot
 */
@interface FSPopup : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get open status.
 *
 * @details	Open status is a boolean value that specifies whether a pop-up annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @return	Open status:
 *			<ul>
 *			<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *			</ul>
 */
-(BOOL)getOpenStatus;
/**
 * @brief	Set open status.
 *
 * @details	Open status is a boolean value that specifies whether a pop-up annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @param[in]	status	The new open status value:
 *				<ul>
 *				<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *				<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *				</ul>
 */
-(void)setOpenStatus:(BOOL)status;
    
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a markup annotation.
 *
 * @details	Markup annotations are are used primarily to mark up PDF documents. These annotations have
 *			text that appears as part of the annotation and may be displayed in other ways by
 *			a viewer application, such as in a Comments pane.<br>
 *			Class ::FSMarkup is derived from class ::FSAnnot, and is also the base class for all PDF markup annotations.
 *			It offers the base functions to access markup annotation's common properties.
 *			For concrete markup annotation types, please refer to derived classes. <br>
 *			Function {@link FSAnnot::isMarkup} can be used to judge if an annotation is a markup annotation.
 *
 * @note	Currently, following kind of functions only support note, highlight, underline, strikeout, squiggly,
 *			square, circle, free text, stamp, caret, ink, line, polygon, polyline, file attachment annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSMarkup.</li>
 *			<li>2. Function {@link FSMarkup::resetAppearanceStream}.</li>
 *			</ul>
 *
 * @see	FSAnnot
 */
@interface FSMarkup : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Get related pop-up annotation.
 *
 * @details	Most markup annotations can have a pop-up annotation to show their content, except sound and free text annotations.<br>
 *			For sound annotation, it does not have a pop-up annotation.<br>
 *			For free text annotation, it shows text directly on the page, so no need to have a pop-up annotation. <br>
 *			Though, in some special(or error) PDF document, sound or free text annotation may have a pop-up annotation, they still do not need a pop-up
 *             annotation.<br>
 *
 * @return	The related pop-up annotation. <br>
 *			If current markup annotation does not have a pop-up annotation, this function will return <b>nil</b>.
 */
-(FSPopup*)getPopup;
/**
 * @brief	Set related pop-up annotation.
 *
 * @details	Most markup annotations can have a pop-up annotation to show their content, except sound and free text annotations.<br>
 *			For sound annotation, it does not have a pop-up annotation.<br>
 *			For free text annotation, it shows text directly on the page, so no need to have a pop-up annotation.<br>
 *			So, this function does not allow to set pop-up annotation to sound and free text annotation.
 *
 * @param[in]	popup	The new related popup annotation. It should not be <b>nil</b>.
 */
-(void)setPopup:(FSPopup*)popup;
/**
 * @brief	Get title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/** 
 * @brief	Set title string.
 *
 * @param[in]	title		New title string to be set.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get subject.
 *
 * @return	Subject string.
 */
-(NSString *)getSubject;
/**
 * @brief	Set subject.
 *
 * @param[in]	subject		New subject string to be set.
 */
-(void)setSubject: (NSString *)subject;
/**
 * @brief	Get opacity.
 *
 * @return	The opacity value. Valid range: from 0.0 to 1.0.
 */
-(float)getOpacity;
/**
 * @brief	Set opacity.
 *
 * @param[in]	opacity		The new opacity value. Valid range: 0.0 to 1.0 .
 */
-(void)setOpacity: (float)opacity;
/**
 * @brief	Get intent name.
 *
 * @details	Following annotation types have predefined intent name:<br>
 *			<ul>
 *			<li>Free text annotation's predefined intent name: "FreeTextCallout", "FreeTextTypewriter".
 *				If no intent name is used, free text annotation would be shown as a text box.
 *			</li>
 *			<li>Line annotation's predefined intent name: "LineArrow", "LineDimension".
 *				If no intent name is used, line annotation would be shown as a common line.
 *			</li>
 *			<li>Polygon's predefined intent name: "PolygonCloud", "PolygonDimension".
 *				If no intent name is used, polygon annotation would be shown as a common polygon.
 *			</li>
 *			<li>Polyline annotation's predefined intent name: "PolyLineDimension".
 *				If no intent name is used, polyline annotation would be shown as a common polyline.
 *			</li>
 *			</ul>
 *
 * @return	The intent name string, in UTF-8 encoding.
 */
-(NSString *)getIntent;
/**
 * @brief	Set intent name.
 *
 * @details	Following annotation types have predefined intent name:<br>
 *			<ul>
 *			<li>Free text annotation's predefined intent name: "FreeTextCallout", "FreeTextTypewriter".
 *				If no intent name is used, free text annotation would be shown as a text box.
 *			</li>
 *			<li>Line annotation's predefined intent name: "LineArrow", "LineDimension".
 *				If no intent name is used, line annotation would be shown as a common line.<br>
 *				Currently, not support to set "LineDimension" as a line annotation's intent.
 *			</li>
 *			<li>Polygon's predefined intent name: "PolygonCloud", "PolygonDimension".
 *				If no intent name is used, polygon annotation would be shown as a common polygon.<br>
 *				Currently, not support to set "PolygonDimension" as a polygon annotation's intent.<br>
 *				If a polygon annotation's intent is to be set to "PolygonCloud", the polygon annotation's border style will be changed to
 *				{@link FSM_BORDERSTYLE::e_borderStyleCloudy} and FSBorderInfo::cloudIntensity will be set to 2 by default.
 *			</li>
 *			<li>Polyline annotation's predefined intent name: "PolyLineDimension".
 *				If no intent name is used, polyline annotation would be shown as a common polyline.<br>
 *				Currently, not support to set "PolyLineDimension" as a polyline annotation's intent.
 *			</li>
 *			</ul>
 *
 * @param[in]	intent		New intent name string to be set.
 *							If it is <b>nil</b> or an empty string, that means the intent property will not be used.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 *							Some annotation type have predefined intent name, please refer to "Details" part for more details.
 *							If this string is one of those unsupported intent name, this string will be ignored when set to related annotations.
 */
-(void)setIntent: (NSString *)intent;
/**
 * @brief	Get creation date time.
 *
 * @return	A date time instance.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Set creation date time.
 *
 * @param[in]	dateTime	The new date time to be set.
 */
-(void)setCreationDateTime: (FSDateTime*)dateTime;
/**
 * @brief	Count all replies.
 *
 * @return	The count of replies.
 */
-(int)getReplyCount;
/**
 * @brief	Get a reply by index.
 *
 * @param[in]	index	The index for a specified reply. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	A note annotation instance which is used as a reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)getReply: (int)index;
/**
 * @brief	Add a reply to the end of reply list.
 *
 * @return	A new note annotation instance which is used as the new reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)addReply;
/**
 * @brief	Remove a reply by index.
 *
 * @details	If specific reply has its own replies, these sub replies will be removed at the same time.
 *
 * @param[in]	index	The index for a specified reply to be removed. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeReply: (int)index;
/**
 * @brief	Remove all replies.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAllReplies;
/**
 * @brief	Check whether current markup annotation is in a group or not.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	<b>YES</b> means current markup annotation is in a group.
 *			<b>NO</b> means current markup annotation does not belong to any group.
 */
-(BOOL)isGrouped;

/**
 * @brief	Get the header annotation (as primary annotation) of the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	The header markup annotation of the group that current markup annotation belongs to.
 *			If current annotation does not belong to a group or there is any error, this function will return <b>nil</b>.
 */
-(FSMarkup*)getGroupHeader;

/**
 * @brief	Count the elements in the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	The count of elements in the group that current markup annotation belongs to.
 */
-(int)getGroupElementCount;

/**
 * @brief	Get an element (as markup annotation) from the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @param[in]	index		The index of the element to be retrieved. Valid range: from 0 to (<i>count</i> - 1).
 *							<i>count</i> is returned by function {@link FSMarkup::getGroupElementCount}.
 *
 * @return	The markup annotation from the group, specified by index.
 *			If current annotation does not belong to a group or there is any error, this function will return <b>nil</b>.
 */
-(FSMarkup*)getGroupElement : (int)index;

/**
 * @brief	Ungroup current markup annotation from the group it belongs to.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means current markup annotation does not belong to any group or any other failure.
 */
-(BOOL)ungroup;

/**
 * @brief	Get the count of state annotations, under a specified state model.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...
 *
 * @param[in]	stateModel 	State model. It should be one of following values:
 *							<ul>
 *							<li>{@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}</li>
 *							<li>{@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}</li>
 *							</ul>
 *
 * @return	The count of states for the specified state model.
 */
-(int)getStateAnnotCount: (enum FS_ANNOTSTATEMODEL)stateModel;

/**
 * @brief	Get a state annotation, under a specified state model.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...
 *
 * @param[in]	stateModel 	State model. It should be one of following values:
 *							<ul>
 *							<li>{@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}</li>
 *							<li>{@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}</li>
 *							</ul>
 * @param[in]	index		The index of the state annotation to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSMarkup::getStateAnnotCount:} with the same parameter <i>stateModel</i>.
 *
 * @return	The state annotation, represented by a note annotation.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSNote*)getStateAnnot: (enum FS_ANNOTSTATEMODEL)stateModel index: (int)index;

/**
 * @brief	Add a new state annotation.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...<br>
 *
 * @param[in]	stateModel	State model for the new state annotation. It should be one of following values:
 *							<ul>
 *							<li>{@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked}:
 *								<ul>
 *								<li>If current markup annotation already has a state annotation in marked state model, this function will set the new state value
 *								the existed marked state model directly instead of adding a new one.
 *								</li>
 *								<li>If current markup annotation does not have a state annotation in marked state model, this function will add a new one.
 *								</li>
 *								</ul>
 *							</li>
 *							<li>{@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview}:
 *								<ul>
 *								<li>If current markup annotation already has state annotations in reviewed state model, this function will add a new one
 *									to refer to the last state annotation in reviewed state model.
 *								</li>
 *								<li>If current markup annotation does not have any state annotation in reviewed state model, this function will add a new one
 *									to refer to current markup annotation.
 *								</li>
 *								</ul>
 *							</li>
 *							</ul>
 * @param[in]	state		State value for the new state annotation. It should be one of following values:
 *							<ul>
 *							<li>If parameter <i>stateModel</i> is {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateMarked} or {@link FSM_ANNOTSTATE::e_annotStateUnmarked}.
 *							</li>
 *							<li>If parameter <i>stateModel</i> is {@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateAccepted}, {@link FSM_ANNOTSTATE::e_annotStateRejected}, {@link  FSM_ANNOTSTATE::e_annotStateCancelled},
 *								{@link FSM_ANNOTSTATE::e_annotStateCompleted}, or {@link FSM_ANNOTSTATE::e_annotStateNone}.
 *							</li>
 *							</ul>
 *
 * @return	A new state annotation, represented by a note annotation.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSNote*)addStateAnnot: (enum FS_ANNOTSTATEMODEL)stateModel state: (enum FS_ANNOTSTATE)state;

/**
 * @brief	Remove all state annotations.
 *
 * @details	State annotation is represented by note annotation,
 *			so, to remove state annotations also means to remove the special note annotations (with its popup if any) from the page.
 *
 * @return	<b>YES</b> means remove all the state annotations successfully or current annotation does not have any state annotation,
 *			while <b>NO</b> means failure.<br>
 */
-(BOOL)removeAllStateAnnots;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a note annotation.
 *
 * @details	A note annotation (known as "text" annotation in <PDF reference 1.7>) represents a "sticky note"
 *			attached to a point in the PDF document. When closed, the annotation appears as an icon;
 *			when open, it displays a pop-up window containing the text of the note in a font and size
 *			chosen by the viewer application. <br>
 *			A note annotation can also be used as a reply to a markup annotation, or a state annotation:
 *			<ul>
 *			<li>When as a reply, the note annotation should not be shown alone but together with other replies in the form of threaded comments.
 *				Function {@link FSNote::getReplyTo} can be used to get the markup annotation, to which the note annotation replies.
 *			</li>
 *			<li>When as a state, the note annotation would not be shown alone.
 *				Function {@link FSNote::isStateAnnot} can be used to judge if a note annotation is used as a state.
 *			</li>
 *			</ul>
 *			Note annotation is a kind of markup annotation, so class ::FSNote is derived from class ::FSMarkup.
 *			It offers functions to access note annotation's properties and reset appearance of a note annotation.
 *
 * @note	For a newly created common note annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFFFF00 (yellow), opacity = 1.0, icon name = "Comment".
 *
 * @see	FSMarkup
 */
@interface FSNote : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Get open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @return	Open status.
 */
-(BOOL)getOpenStatus;
/** 
 * @brief	Set open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @param[in]	status	The new open status value.
 */
-(void)setOpenStatus: (BOOL)status;
/**
 * @brief	Get icon name.
 *
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Check", "Circle", "Comment", "Cross", "Help",
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph",
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpLeftArrow".<br>
 *			An empty icon name string means current note annotation would be treated as "Note" icon.<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString *)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Check", "Circle", "Comment", "Cross", "Help",
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph",
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpLeftArrow".<br>
 *			An empty icon name string means current note annotation would be treated as "Note" icon.<br>
 *			For a newly created note annotation, if current function is not called, icon name will be "Comment" by default.
 *
 * @param[in]	iconName	New icon name string to be set.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName: (NSString *)iconName;
/**
 * @brief	Get the markup annotation, which current note annotation is in reply to.
 *
 * @details	This function is only useful when current note annotation is used as a reply.
 *
 * @return	A markup annotation object, which current note annotation is in reply to.
 *			If current note annotation is not used as a reply, this function will return <b>nil</b>.
 */
-(FSMarkup*)getReplyTo;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Check if current note annotation is used as a state annotation.
 *
 * @return	<b>YES</b> means current note annotation is used as a state annotation,
 *			while <b>NO</b> means current note annotation is just a common note annotation.
 */
-(BOOL)isStateAnnot;
/**
 * @brief	Get the state model.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this.
 *
 * @return	The state model.
 *			If function succeeds, the return value would be {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked} or {@link
 *              FS_ANNOTSTATEMODEL::e_annotStateModelReview}.<br>
 *			If current note annotation is not a state annotation or there is any error, this function will return 0.
 */
-(enum FS_ANNOTSTATEMODEL)getStateModel;
/**
 * @brief	Get the state.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this status.
 *
 * @return	The state.
 *			Please refer to {@link FSM_ANNOTSTATE::e_annotStateMarked FSM_ANNOTSTATE::e_annotStateXXX} values and it would be one of these values.
 *			If current note annotation is not a state annotation or there is any error, This function will return 0.
 */
-(enum FS_ANNOTSTATE)getState;
/**
 * @brief	Set the state.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this.
 *
 * @param[in]	state		New state. It should be one of following values:
 *							<ul>
 *							<li>If state model is  {@link FS_ANNOTSTATEMODEL::e_annotStateModelMarked}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateMarked} or {@link FSM_ANNOTSTATE::e_annotStateUnmarked}.
 *							</li>
 *							<li>If state model is {@link FS_ANNOTSTATEMODEL::e_annotStateModelReview}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateAccepted}, {@link FSM_ANNOTSTATE::e_annotStateRejected}, {@link FSM_ANNOTSTATE::e_annotStateCancelled},
 *								{@link FSM_ANNOTSTATE::e_annotStateCompleted}, or {@link FSM_ANNOTSTATE::e_annotStateNone}.
 *							</li>
 *							</ul>
 *							State model can be gotten by fucntion {@link FSNote::getStateModel}.
 */
-(void)setState: (enum FS_ANNOTSTATE)state;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a text markup annotation.
 *
 * @details	Text markup annotations appear as highlights, underlines, strikeouts,
 *			or squiggly lines in the text of a document.<br>
 *			Text markup annotations are all markup annotations, so class ::FSTextMarkup is derived from class ::FSMarkup.
 *			It is the base class for all PDF text markup annotations. It offers the base functions
 *			to access text markup annotation's common properties. <br>
 *			Especially, for a text markup annotation, quadrilaterals are required. So please ensure that a text markup annotation
 *			has valid quadrilaterals before resetting its appearance stream. <br>
 *			For concrete text markup annotation types, please refer to derived classes.
 *
 * @see	FSMarkup
 */
@interface FSTextMarkup : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/** 
 * @brief	Get a quadrilaterals by index.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSTextMarkup::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/** 
 * @brief	Set quadrilaterals.
 *
 * @details	For a text markup annotation, quadrilaterals are required.
 *			After setting new quadrilaterals, rectangle of current text markup annotation will be updated as well. <br>
 *			The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 *
 * @param[in]	quadPoints		A valid quadrilateral array. It should contains at least one valid quadrilateral.
 */
-(void)setQuadPoints: (NSArray*)quadPoints;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a highlight annotation.
 *
 * @details	Highlight annotation is a kind of text markup annotation, which is shown as
 *			a highlight area for the text in a PDF document.
 *			Class ::FSHighlight is derived from ::FSTextMarkup and offers function to reset appearance stream of a highlight annotation.
 *			For a highlight annotation, quadrilaterals are required. So please ensure that a highlight annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created highlight annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFFED00 (a kind of yellow), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSHighlight : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a highlight annotation, please ensure this highlight annotation has valid quadrilaterals;
 *			otherwise this highlight annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a underline annotation.
 *
 * @details	Underline annotation is a kind of text markup annotation, which is shown as
 *			a underline under the text in a PDF document.
 *			Class ::FSUnderline is derived from ::FSTextMarkup and offers function to reset appearance stream of a underline annotation.
 *			For a underline annotation, quadrilaterals are required. So please ensure that a underline annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created underline annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFF339E00 (a kind of green), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSUnderline : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a underline annotation, please ensure this underline annotation has valid quadrilaterals;
 *			otherwise this underline annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a strikeout annotation.
 *
 * @details	Strikeout annotation is a kind of text markup annotation, which is shown as
 *			a strikeout line in the middle of the text in a PDF document.
 *			Class ::FSStrikeOut is derived from ::FSTextMarkup and offers function to reset appearance stream of a strikeout annotation.
 *			For a strikeout annotation, quadrilaterals are required. So please ensure that a strikeout annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created strikeout annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFF94244 (a kind of red), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSStrikeOut : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
	 *
 * @details	Before resetting appearance stream of a strikeout annotation, please ensure this strikeout annotation has valid quadrilaterals;
 *			otherwise this strikeout annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a squiggly annotation.
 *
 * @details	Squiggly annotation is a kind of text markup annotation, which is shown as
 *			a squiggly line under the text in a PDF document.
 *			Class ::FSSquiggly is derived from ::FSTextMarkup and offers function to reset appearance stream of a squiggly annotation.
 *			For a squiggly annotation, quadrilaterals are required. So please ensure that a squiggly annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created squiggly annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFF4899FF (a kind of blue), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSSquiggly : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
	  *
 * @details	Before resetting appearance stream of a squiggly annotation, please ensure this squiggly annotation has valid quadrilaterals;
 *			otherwise this squiggly annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a square annotation.
 *
 * @details	Square annotation is a rectangle on the page. Despite the name "square", a square annotation can represent either a square or a rectangle,
 *			which means the width and height of the annotation rectangle need not be equal.<br>
 *			Square annotation is a kind of markup annotation, so class ::FSSquare is derived from class ::FSMarkup, and also offers functions
 *			to access square annotation's properties and reset appearance stream of a square annotation.
 *
 * @note	For a newly created square annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid}.
 *
 * @see	FSMarkup
 */
@interface FSSquare : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setFillColor:(unsigned int)fillColor;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a square annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a square annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void) setInnerRect: (FSRectF*) innerRect;
/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a circle annotation.
 *
 * @details	Circle annotation is an ellipse on the page. Despite the name "circle", a circle annotation can represent either a circle or a oval,
 *			which means the width and height of the annotation rectangle need not be equal.<br>
 *			Circle annotation is a kind of markup annotation, so class ::FSCircle is derived from class ::FSMarkup, and also offers functions
 *			to access circle annotation's properties and reset appearance stream of a circle annotation.
 *
 * @note	For a newly created circle annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid}.
 *
 * @see	FSMarkup
 */
@interface FSCircle : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setFillColor:(unsigned int)fillColor;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a circle annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a circle annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void) setInnerRect: (FSRectF*) innerRect;
/*** @brief Free the object.*/
-(void)dealloc;

@end
    

/**
 * @brief	Class to access a link annotation.
 *
 * @details	A link annotation represents an action to be performed.<br>
 *			Class ::FSLink is derived from ::FSAnnot, and offers functions to access link annotation's properties
 *			and reset appearance stream of a link annotation.
 *
 * @note	For a newly created link annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any other properties, the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			highlighting mode = {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeNone}.
 *
 * @see	FSAnnot
 */
@interface FSLink : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/** 
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/** 
 * @brief	Get a quadrilateral by index.
 *
 * @details The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSLink::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/**
 * @brief	Set quadrilaterals.
 *
 * @details	The order of points in a quadrilateral should be :
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *			If any single point of the new quadrilaterals is outside the region defined by rectangle of current link annotation,
 *			new quadrilaterals will not be ignored and not set to current link annotation.
 *
 * @param[in]	quadPoints		A valid array of quadrilaterals. It should not be <b>nil</b>.
 */
-(void)setQuadPoints : (NSArray*)quadPoints;
/**
 * @brief	Get highlighting mode.
 *
 * @return	Highlighting mode value. Please refer to {@link FS_HIGHLIGHTINGMODE::e_highlightingModeNone FS_HIGHLIGHTINGMODE::e_highlightingModeXXX} values
 *			and it would be one of these values except {@link FS_HIGHLIGHTINGMODE::e_highlightingModeToggle}.
 *			-1 means no highlighting mode value is found or error.
 */
-(enum FS_HIGHLIGHTINGMODE)getHighlightingMode;
/**
 * @brief	Set highlighting mode.
 *
 * @param[in]	mode		New highlighting mode value.
 *							Please refer to {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeNone FSM_HIGHLIGHTINGMODE::e_highlightingModeXXX} values
 *							and it should be one of these values except {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeToggle}.
 */
-(void)setHighlightingMode : (enum FS_HIGHLIGHTINGMODE) mode;
/**
 * @brief	Get action.
 *
 * @return	A ::FSAction object that receives the action data.
 *			<b>nil</b> means no action or failure.
 */
-(FSAction*)getAction;
/**
 * @brief	Set action.
 *
 * @param[in]	action		New action to be set. It should be valid.
 *							Currently only support following types as the new action:<br>
 *							{@link FS_ACTIONTYPE::e_actionTypeGoto}, {@link FS_ACTIONTYPE::e_actionTypeURI}.
 */
-(void)setAction : (FSAction*) action;
/**
 * @brief	Remove action.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAction;

/** @brief Free the object. */
-(void)dealloc;

@end

    
/**
 * @brief	Class to access a free text annotation.
 *
 * @details	A free text annotation displays text directly on the page. So free text annotation does not need a related pop-up annotation to show the text.<br>
 *			Free text annotation is a kind of markup annotation, so class ::FSFreeText is derived from class ::FSMarkup, and also offers functions
 *			to access free text annotation's properties and reset appearance stream of a free text annotation. <br>
 *
 * @note	For a newly created free text annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0, alignment = 0 (as left-justified),
 *			{@link FSDefaultAppearance::flags} = {@link FS_DEFAULTAPFLAGS::e_defaultAPFont}|{@link FS_DEFAULTAPFLAGS::e_defaultAPTextColor}|{@link FS_DEFAULTAPFLAGS::e_defaultAPFontSize},
 *			{@link FSDefaultAppearance::font} is created based on {@link FS_STANDARDFONTID::e_fontStandardIDHelvetica},
 *			{@link FSDefaultAppearance::fontSize} = 12, {@link FSDefaultAppearance::textColor} = 0xFF0000FF (blue).
 *
 * @see	FSMarkup
 */
@interface FSFreeText: FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color.
 *
 * @details	Fill color is used to fill the background of text box, and also for some callout line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getFillColor;
/**
 * @brief	Set fill color.
 *
 * @details	Fill color is used to fill the background of text box, and also for some callout line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setFillColor: (unsigned int)fillColor;
/**
 * @brief	Get alignment.
 *
 * @return	An integer value that indicates the alignment:
 *			<ul>
 *			<li>0: Left-justified</li>
 *			<li>1: Centered</li>
 *			<li>2: Right-justified</li>
 *			</ul>
 *			If there is any error, this function will return -1.
 */
-(int)getAlignment;
/**
 * @brief	Set alignment.
 *
 * @param[in]	alignment	An integer value that specifies the new alignment. It should be one of following values:
 *							<ul>
 *							<li>0: Left-justified</li>
 *							<li>1: Centered</li>
 *							<li>2: Right-justified</li>
 *							</ul>
 *							If other values is used to set, 0 will be used by default.
 */
-(void)setAlignment: (int)alignment;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a free text annotation, inner rectangle is where the annotation's text should be displayed.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*)getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a free text annotation, inner rectangle is where the annotation's text should be displayed.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void)setInnerRect: (FSRectF*)innerRect;
/**
 * @brief	Get default appearance data.
 *
 * @details	Default appearance data can be used in formatting text.
 *
 * @return	The default appearance data.
 *			If there is any error, a FSDefaultAppearance object with following values will be returned:
 *			{@link FSDefaultAppearance::flags} = 0, {@link FSDefaultAppearance::font} = nil,
 *			{@link FSDefaultAppearance::fontSize} = 0, {@link FSDefaultAppearance::textColor} = 0.
 */
-(FSDefaultAppearance*)getDefaultAppearance;
/**
 * @brief	Set default appearance data.
 *
 * @details	Default appearance data can be used in formatting text.
 *
 * @param[in]	defaultAP	The new default appearance data to be set.
 *							{@link FSDefaultAppearance::flags} can be used to decide which information is/are to be updated with the new data;
 *							for those no updated data, they will keep to use old data.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setDefaultAppearance: (FSDefaultAppearance*)defaultAP;
/**
 * @brief	Get line ending style of the start point in a callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have line ending style property. <br>
 *			Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*) getCalloutLineEndingStyle;
/**
 * @brief	Set line ending style of the start point in a callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have line ending style property.<br>
 *			Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setCalloutLineEndingStyle: (NSString*)startingStyle;
/**
 * @brief	Get the count of callout line points.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @return	The count of callout line points. It would be 2 or 3.
 *			If there is any error, 0 will be returned.
 */
-(int)getCalloutLinePointCount;
/**
 * @brief	Get a point of callout line points.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @param[in]	index	Index of the point to be get. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSFreeText::getCalloutLinePointCount}.
 *
 * @return	The specified point of a callout line.
 */
-(FSPointF*)getCalloutLinePoint: (int)index;
/**
 * @brief	Set points for callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @param[in]	point1	New point that specifies the start point of the callout line. It should be valid.
 * @param[in]	point2	New point that specifies the second point of the callout line.
 *						<ul>
 *						<li>If parameter <i>point3</i> is just the same as current parameter <i>point2</i>,
 *							the callout line only consists of 2 points, and <i>point2</i> represents the ending point.</li>
 *						<li>If parameter <i>point3</i> is different from current parameter <i>point2</i>,
 *							the callout line consists of 3 points, and <i>point2</i> represents the knee point.</li>
 *						</ul>
 * @param[in]	point3	New point that specifies the third point of the callout line. It can be:
 *						<ul>
 *						<li>If this is just the same as parameter <i>point2</i>, the callout line only consists of 2 points.</li>
 *						<li>If this is valid, the callout line consists of 3 points.</li>
 *						</ul>
 */
-(void)setCalloutLinePoints:(FSPointF*)point1 point2:(FSPointF*)point2  point3:(FSPointF*)point3;
/** @brief	Free the object. */
-(void)dealloc;
@end

    
/**
 * @brief	Class to access a line annotation.
 *
 * @details	A line annotation displays a single straight line on the page.<br>
 *			Line annotation is a kind of markup annotation, so class ::FSLine is derived from class ::FSMarkup, and also offers functions
 *			to access line annotation's properties and reset appearance stream of a line annotation. <br>
 *			For a line annotation, start point and end point are required. So please ensure that a line annotation
 *			has valid start point and end point before resetting its appearance stream.
 *
 * @note	For a newly created line annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required start point and end point property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1,
 *			line starting/ending styles = "None", no caption is enabled.
 *
 *
 * @see	FSMarkup
 */
@interface FSLine : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a line annotation, please ensure this line annotation has valid start point and end point;
 *			otherwise this line annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get line ending style of the start point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*) getLineStartingStyle;
/**
 * @brief	Set line ending style of the start point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineStartingStyle : (NSString*)startingStyle;
/**
 * @brief	Get line ending style of the end point in a line.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the end point.
 */
-(NSString*)getLineEndingStyle;
/**
 * @brief	Set line ending style of the end point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	endingStyle		 String of new line ending style for the end point to be set. It should be in UTF-8 encoding.
 *								 If this is <b>nil</b> or an empty string, "None" will be used as default.
 *								 Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineEndingStyle : (NSString*)endingStyle;
/**
 * @brief	Get fill color for ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color of ending styles. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getStyleFillColor;
/**
 * @brief	Set fill color of ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	color		New fill color of ending style. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setStyleFillColor : (unsigned int) color;
/**
 * @brief	Get the start point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @return	The start point.
 *			A ::FSPointF with value (0, 0) may also mean that no start point is found or there is any error.
 */
-(FSPointF*)getStartPoint;
/**
 * @brief	Set the start point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @param[in]	point	New point that specifies the start point.
 */
-(void)setStartPoint : (FSPointF*) point;
/**
 * @brief	Get the end point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @return	The end point.
 *			A ::FSPointF with value (0, 0) may also mean that no start point is found or there is any error.
 */
-(FSPointF*) getEndPoint;
/**
 * @brief	Set the end point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @param[in]	point	New point that specifies the end point.
 */
-(void)setEndPoint : (FSPointF*) point;
/**
 * @brief	Check whether the content of current line annotation should be replicated as a caption in the appearance or not.
 *
 * @return	<b>YES</b> means the content should be replicated as a caption in the appearance of current line annotation.
 *			<b>NO</b> means not to replicate the content as a caption in the appearance of current lint annotation.
 */
-(BOOL)hasCaption;
/**
 * @brief	Set the flag which is used to decide whether the content of current line annotation
 *			should be replicated as a caption in the appearance or not.
 *
 * @param[in]	cap		<b>YES</b> means the content should be replicated as a caption in the appearance of current line annotation,
 *						while <b>NO</b> means not.
 */
-(void)enableCaption : (BOOL)cap;
/**
 * @brief	Get the position type of caption.
 *
 * @details	Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *			There are two position types of caption:
 *			<ul>
 *			<li>"Inline": means the caption will be centered inside the line.</li>
 *			<li>"Top": means the caption will be on top of the line.</li>
 *			</ul>
 *
 * @return	A string that represents the position type of caption.
 *			If no position type can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getCaptionPositionType;
/**
 * @brief	Set the position type of caption.
 *
 * @details	Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *			There are two position types of caption:
 *			<ul>
 *			<li>"Inline": means the caption will be centered inside the line.</li>
 *			<li>"Top": means the caption will be on top of the line.</li>
 *			</ul>
 *
 * @param[in]	captionPos	 String as position type. It should be one of following string values: "Inline" or "Top".
 */
-(void)setCaptionPositionType : (NSString*)captionPos;
/**
 * @brief	Get caption offset values.
 *
 * @details	Caption offset is the offset of caption from its normal position.<br>
 *			Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *
 * @return	A ::FSOffset object that receives horizontal offset and vertical offset for caption.<br>
 *			A ::FSOffset object with value (0, 0) may also mean that no caption offset values can be found or there is any error.
 */
-(FSOffset*) getCaptionOffset;
/**
 * @brief	Set caption offset values.
 *
 * @details	Caption offset is the offset of caption from its normal position.<br>
 *			Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *
 * @param[in]	offset		New offset values .
 */
-(void)setCaptionOffset : (FSOffset*)offset;
/** @brief	Free the object. */
-(void)dealloc;
@end
    
/**
 * @brief	Class to represent ink annotation.
 *
 * @details	An ink annotation represents a freehand "scribble" composed of one or more disjoint paths. <br>
 *			Ink annotation is a kind of markup annotation, so class ::FSInk is derived from class ::FSMarkup, and also offers functions
 *			to access ink annotation's properties and reset appearance stream of an ink annotation. <br>
 *			For a ink annotation, ink list property is required. So please ensure that an ink annotation
 *			has valid ink list property before resetting its appearance stream.
 *
 * @note	For a newly created ink annotation, if user calls function {@link FSInk::resetAppearanceStream} directly
 *			after setting required ink list property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSInk : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of an ink annotation, please ensure this ink annotation has valid ink list;
 *			otherwise this ink annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get ink list data.
 *
 * @details	Ink list property is required for an ink annotation.
 *			The ink list contains one or more stroked path. <br>
 *			In Foxit PDF SDK, class ::FSPDFPath is used to represent the ink list data,
 *			but the point types for ::FSPDFPath object have been specially simplified for ink list.
 *			Only {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} and {@link FS_PATHPOINTTYPE::e_pointTypeLineTo} types are used for points in the ink list:
 *			<ul>
 *			<li>a point with type {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} means that this point is the start point of a stroked path.
 *				Usually the first in ::FSPDFPath object should be this type.
 *			</li>
 *			<li>a point with type {@link FS_PATHPOINTTYPE::e_pointTypeLineTo} means that this point is in a stroked path,
 *				which is started by a point with with type {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo},
 *				and when function {@link FSInk::resetAppearanceStream} is called, Foxit PDF SDK will connect this point with other points by curves.</li>
 *			</ul>
 * @note    Operations such as move the ink annotation, or set a new ink path to this annotation will update its internal ink path data, so that the
 *          previous returned FSPDFPath object would become invalid. Caller must call this API to obtain a new FSPDFPath object. 
 *
 * @return	The ink list data.<br>
 *			If no ink list data can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSPDFPath*)getInkList;
/**
 * @brief	Set ink list data.
 *
 * @details	Ink list property is required for an ink annotation.
 *			The ink list contains one or more stroked path. <br>
 *			In Foxit PDF SDK, class ::FSPDFPath is used to represent the ink list data,
 *			but the point types for ::FSPDFPath object have been specially simplified for ink list.
 *			Only {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} and {@link FS_PATHPOINTTYPE::e_pointTypeLineTo} types are used for points in the ink list:
 *			<ul>
 *			<li>a point with type {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} means that this point is the start point of a stroked path.
 *				Usually the first in ::FSPDFPath object should be this type.
 *			</li>
 *			<li>a point with type {@link FS_PATHPOINTTYPE::e_pointTypeLineTo} means that this point is in a stroked path,
 *				which is started by a point with with type {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo},
 *				and when function {@link FSInk::resetAppearanceStream} is called, Foxit PDF SDK will connect this point with other points by curves.</li>
 *			</ul>
 *			Specially, if input parameter <i>inkList</i> contains bezier points (for example, added by function {@link FSPDFPath::cubicBezierTo:point2:point3:}), the control points will be ignored
 *			and only the target point will be used in the ink list data.<br>
 *			User is strongly recommended to pass a valid ::FSPDFPath object only with point types {@link FS_PATHPOINTTYPE::e_pointTypeMoveTo} and {@link FS_PATHPOINTTYPE::e_pointTypeLineTo}.
 *
 *
 * @param[in]	inkList		New ::FSPDFPath object which specifies the new list data.
 */
-(void)setInkList :(FSPDFPath*) inkList;
/** @brief	Free the object. */
-(void)dealloc;
@end
    
    
/**
 * @brief	Class to access a stamp annotation.
 *
 * @details	A stamp annotation displays text or graphics intended to look as if they were stamped on the page with a rubber stamp.<br>
 *			A stamp annotation's appearance can be with an icon or a bitmap.
 *			Currently, Foxit PDF SDK does not have any default appearance for predefined standard stamp icons,
 *			so user should set a customized annotation icon provider to Foxit PDF SDK
 *			by function {@link FSLibrary::setAnnotIconProvider:} if the stamp is represented by icon.<br>
 *			Stamp annotation is a kind of markup annotation, so class ::FSStamp is derived from class ::FSMarkup, and also offers functions
 *			to access stamp annotation's properties and reset appearance stream of a stamp annotation.
 *
 * @note	For a newly created stamp annotation, some properties will be set with default values:<br>
 *			opacity = 1.0, icon name = "Draft".<br>
 *			Before calling {@link FSStamp::resetAppearanceStream}, user should ensure to set a bitmap to the stamp by function {@link FSStamp::setBitmap:},
 *			or set a useful customized annotation icon provider to Foxit PDF SDK by function {@link FSLibrary::setAnnotIconProvider:}.
 *
 * @see	FSMarkup
 * @see FSLibrary
 */
@interface FSStamp : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a stamp annotation, please ensure this stamp annotation has been set valid bitmap,
 *			or it has an icon name, with the supported customized annotation icon provider being set to Foxit PDF SDK;
 *			otherwise this stamp annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get icon name.
 *
 * @details	Stamp annotation has predefined standard icon names: <br>
 *			"Approved", "AsIs", "Confidential", "Departmental", "Draft",
 *			"Experimental", "Expired", "Final", "ForComment", "ForPublicRelease",
 *			"NotApproved", "NotForPublicRelease", "Sold", "TopSecret".<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString*)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	Stamp annotation has predefined standard icon names: <br>
 *			"Approved", "AsIs", "Confidential", "Departmental", "Draft",
 *			"Experimental", "Expired", "Final", "ForComment", "ForPublicRelease",
 *			"NotApproved", "NotForPublicRelease", "Sold", "TopSecret".<br>
 *			Once user set a new icon name to current stamp annotation, please ensure the customized icon provider has been set to Foxit PDF SDK
 *			by function {@link FSLibrary::setAnnotIconProvider:} before function {@link FSStamp::resetAppearanceStream} is called.
 *			For a newly created note annotation, if current function is not called, icon name will be "Draft" by default.<br>
 *
 * @param[in]	iconName	New icon name string to be set.
 *							An empty icon name string means icon of current note annotation would be treated as "Draft".<br>
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName :(NSString*)iconName;
/**
 * @brief	Set bitmap to current stamp annotation.
 *
 * @param[in]	bitmap	A bitmap to be set to current stamp.
 */
-(void)setBitmap :(FSBitmap*) bitmap;
/** @brief	Free the object. */
-(void)dealloc;
@end
    
/**
 * @brief	Class to access a polygon annotation.
 *
 * @details	A polygon annotation displays a closed polygon on the page.
 *			Polygon annotation is a kind of markup annotation, so class ::FSPolygon is derived from class ::FSMarkup, and also offers functions
 *			to access polygon annotation's properties and reset appearance stream of a polygon annotation. <br>
 *			For a polygon annotation, vertexes property is required. So please ensure that a polygon annotation
 *			has valid vertexes property before resetting its appearance stream.
 *
 * @note	For a newly created polygon annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required vertexes property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSPolygon : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a polygon annotation, please ensure this polygon annotation has valid vertexes property;
 *			otherwise this polygon annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setFillColor : (unsigned int)fillColor;
/**
 * @brief	Get the count of vertexes.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @return	The count of vertexes.
 */
-(int)getVertexCount;
/**
 * @brief	Get the point value of a vertex, specified by index.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @param[in]	index	The index of a vertex.Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPolygon::getVertexCount}.
 *
 * @return	The point value of a specified vertex.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*)getVertex :(int)index;
/**
 * @brief	Set vertexes.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @param[in]	vertexes		A valid point array for vertexes. It should not be <b>nil</b> and should contains at least 2 points as vertexes.
 */
-(void)setVertexes :(NSArray<FSPointF*>*)vertexes;
/** @brief	Free the object. */
-(void)dealloc;
@end
    
/**
 * @brief	Class to access a polyline annotation.
 *
 * @details	A polyline annotation (PDF 1.5) is similar to a polygon, except that the first and last vertex are
 *			not implicitly connected. <br>
 *			Polyline annotation is a kind of markup annotation, so class ::FSPolyLine is derived from class ::FSMarkup, and also offers functions
 *			to access polyline annotation's properties and reset appearance stream of a polyline annotation. <br>
 *			For a polyline annotation, vertexes property is required. So please ensure that a polyline annotation
 *			has valid vertexes property before resetting its appearance stream.
 *
 * @note	For a newly created polyline annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required vertexes property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSPolyLine : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a polyline annotation, please ensure this polyline annotation has valid vertexes property;
 *			otherwise this polyline annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color for some line ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getStyleFillColor;
/**
 * @brief	Set fill color for some line ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setStyleFillColor : (unsigned int)fillColor;
/**
 * @brief	Get the count of vertexes.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @return	The count of vertexes.
 */
-(int)getVertexCount;
/**
 * @brief	Get the point value of a vertex, specified by index.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @param[in]	index	The index of a vertex. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPolyLine::getVertexCount}.
 *
 * @return	The point value of a specified vertex.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*)getVertex : (int)index;
/**
 * @brief	Set vertexes.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @param[in]	vertexes		A valid point array of vertexes. It should not be <b>nil</b> and should contains at least 2 points as vertexes.
 */
-(void)setVertexes : (NSArray<FSPointF*>*)vertexes;
/**
 * @brief	Get line ending style of the start point.
 *
 * @details	Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*)getLineStartingStyle;
/**
 * @brief	Set line ending style of the start point.
 *
 * @details	Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineStartingStyle : (NSString*)startingStyle;
/**
 * @brief	Get line ending style of the end point.
 *
 * @details	Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the end point.
 */
-(NSString*)getLineEndingStyle;
/**
 * @brief	Set line ending style of the end point.
 *
 * @details	Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	endingStyle	String of new line ending style for the end point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineEndingStyle : (NSString*)endingStyle;
/** @brief	Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a caret annotation.
 *
 * @details	A caret annotation (PDF 1.5) is a visual symbol that indicates the presence of text edits.
 *			Caret annotation is a kind of markup annotation, so class ::FSCaret is derived from class ::FSMarkup, and also offers functions
 *			to access caret annotation's properties and reset appearance stream of a caret annotation. <br>
 *
 * @note	For a newly created caret annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any other properties, the default appearance will be used:<br>
 *			border color = 0xFFA7ABE8 (a kind of purple), opacity = 1.0,
 *
 * @see	FSMarkup
 */
@interface FSCaret :FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a caret annotation, inner rectangle means the actual boundaries of underlying caret.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a caret annotation, inner rectangle means the actual boundaries of underlying caret.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void)setInnerRect : (FSRectF*) innerRect;
/** @brief	Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to access a file attachment annotation.
 *
 * @details	A file attachment annotation (PDF 1.3) contains a reference to a file, which typically is embedded in the PDF file.
 *			File attachment annotation is a kind of markup annotation, so class ::FSFileAttachment is derived from class ::FSMarkup, and also offers functions
 *			to access file attachment annotation's properties and reset appearance stream of a file attachment annotation. <br>
 *
 * @note	For a newly created file attachment annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0, icon name = "PushPin".
 *
 * @see	FSMarkup
 */
@interface FSFileAttachment : FSMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Set a file specification, which should specify an embedded file.
 *
 * @param[in]	fileSpecification	A new file specification object to be set. It should not be <b>nil</b>.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setFileSpec: (FSFileSpec*)fileSpecification;
/**
 * @brief	Get the file specification.
 *
 * @return	The file specification object.
 *			If no file specification property can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSFileSpec*)getFileSpec;
/**
 * @brief	Get icon name.
 *
 * @details	File attachment annotation has predefined standard icon names: <br>
 *			"Graph", "PushPin", "Paperclip", "Tag".<br>
 *			An empty icon name string means current File attachment annotation would be treated as "PushPin".<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString *)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	File attachment annotation has predefined standard icon names: <br>
 *			"Graph", "PushPin", "Paperclip", "Tag".<br>
 *			For a newly created file attachment annotation, if current function is not called, icon name will be "PushPin" by default.
 *
 * @param[in]	iconName	New icon name string to be set.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName: (NSString *)iconName;

-(void)dealloc;

@end
    
/************************************************************************************************
 *									Bookmark													*
 *************************************************************************************************/

/**
 * @brief	Enumeration for bookmark style type.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_BOOKMARKSTYLE
{
	/** @brief	 Show bookmark title as normal text. */
	e_bookmarkStyleNormal = 0x00,
	/** @brief	 Show bookmark title as italic text. */
	e_bookmarkStyleItalic = 0x01,
	/** @brief	 Show bookmark title as bold text. */
	e_bookmarkStyleBold = 0x02
};
/**
 * @brief	Enumeration for bookmark position.
 *
 * @details	Values of this enumeration should be used alone.<br>
 *			Actually, "bookmark position" means the relationship between current bookmark and another bookmark.
 */
enum FS_BOOKMARKPOSITION
{
    /** @brief	 Position as first child. */
    e_bookmarkPosFirstChild	= 0,
    /** @brief	 Position as last child. */
    e_bookmarkPosLastChild = 1,
    /** @brief	Position as previous sibling. */
    e_bookmarkPosPrevSibling = 2,
    /** @brief	Position as next sibling. */
    e_bookmarkPosNextSibling = 3,
    /** @brief	Position as first sibling. */
    e_bookmarkPosFirstSibling = 4,
    /** @brief	Position as last sibling. */
    e_bookmarkPosLastSibling = 5
};
/**
 * @brief	Class to access a PDF bookmark.
 *
 * @details	PDF bookmark is also called "outline". It's a tree-structured hierarchy. It allows user to navigate PDF document easily by selecting one outline.
 *			One bookmark contains a destination or actions to indicate how to response when user selects it.<br>
 *			In order to access the bookmark tree, function {@link FSPDFDoc::getFirstBookmark} must be called first to get the root of the whole bookmark tree.
 *			If the "root bookmark" does not exist, function {@link FSPDFDoc::createFirstBookmark} could be called to create a new "root bookmark".
 *			Here, "root bookmark" is an abstract object. "root bookmark" can only have some child bookmarks but no parent, no next sibling bookmarks or any data
 *			(including bookmark data, destination data and action data). And "root bookmark" cannot be shown on the application UI since it has no data.
 *			So, for a root bookmark, only function {@link FSBookmark::getFirstChild} can be used.<br>
 *			From the root bookmark, the bookmark tree can be traversed and each bookmark node can be accessed.<br>
 *			This class offers several functions to access other bookmarks from current bookmark. For example:
 *			<ul>
 *			<li>To access the parent bookmark, use function {@link FSBookmark::getParent}.</li>
 *			<li>To access the first child bookmark, use function {@link FSBookmark::getFirstChild}.</li>
 *			<li>To access the next sibling bookmark, use function {@link FSBookmark::getNextSibling}.</li>
 *			<li>To insert a new bookmark, use function {@link FSBookmark::insert:pos:}.</li>
 *			<li>To move a bookmark, use function {@link FSBookmark::moveTo:pos:}. </li>
 *			</ul>
 *			This class also offers functions to access the data of a PDF bookmark.
 *
 * @see	FSPDFDoc
 */
@interface FSBookmark : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the parent bookmark.
 *
 * @return	The parent bookmark instance.
 */
-(FSBookmark*)getParent;
/**
 * @brief	Get the first child bookmark.
 *
 * @return	The first child bookmark instance.
 */
-(FSBookmark*)getFirstChild;
/**
 * @brief	Get the next sibling bookmark.
 *
 * @return	The next sibling bookmark instance.
 */
-(FSBookmark*)getNextSibling;
/**
 * @brief	Insert a new bookmark according to the position.
 *
 * @details	For the new bookmark, the color be 0xFF000000 and the style would be {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal} by default.<br>
 *
 * @param[in]	title	Title string for the new bookmark. It should be UTF-8 encoding.
 * @param[in]	pos		The position where the new bookmark item is to be inserted, based on current bookmark.
 *						Please refer to {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild FS_BOOKMARKPOSITION::e_bookmarkPosXXX} values and it would be one of these values.<br>
 *						If current bookmark is just the "root bookmark", parameter <i>pos</i> can only be {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild} or {@link FS_BOOKMARKPOSITION::e_bookmarkPosLastChild}.
 *
 * @return	A new bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSBookmark*)insert: (NSString*)title  pos: (enum FS_BOOKMARKPOSITION)pos;
/**
 * @brief	Move current bookmark to be child or sibling of another bookmark.
 *
 * @details	The root bookmark cannot be moved to be child or sibling of any bookmark in the bookmark tree.
 *
 * @param[in]	destBookmark	The destination bookmark. It should not be current bookmark itself or any descendant of current bookmark.<br>
 *								Current bookmark will be moved to be child or sibling of the destination bookmark.
 * @param[in]	pos				The position where the current bookmark is to be moved to, based on parameter <i>destBookmark</i>.
 *								Please refer to {@link FS_BOOKMARKPOSITION::e_bookmarkPosFirstChild FS_BOOKMARKPOSITION::e_bookmarkPosXXX} values and it would be one of these values.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)moveTo: (FSBookmark*)destBookmark  pos: (enum FS_BOOKMARKPOSITION)pos;
/**
 * @brief	Get the destination of the bookmark.
 *
 * @details	If current bookmark dictionary has /Dest or a goto action (/A), this function can get the destination information directly.
 *			If current bookmark dictionary does not have /Dest or its /A is not a goto action,
 *			no destination information can be retrieved and this function will return <b>nil</b>.
 *
 * @return	The destination instance.
 */
-(FSDestination*)getDestination;
/**
 * @brief	Set the destination.
 *
 * @param[in]	dest	The new destination.
 */
-(void)setDestination: (FSDestination*)dest;
/**
 * @brief	Get the title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get the color.
 *
 * @return	Color used for displaying title.
 *			Format: 0xAARRGGBB. Alpha value is ignored and will always be 0xFF by default.
 */
-(unsigned int)getColor;
/**
 * @brief	Set the color.
 *
 * @param[in]	color	Color used for displaying title. Format:0xAARRGGBB.
 *						Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setColor: (unsigned int)color;
/**
 * @brief	Get bookmark style.
 *
 * @return	The bookmark style values.
 *			This would be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 */
-(unsigned int)getStyle;
/**
 * @brief	Set bookmark style.
 *
 * @param[in]	style	The style of the bookmark. This can be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 *						If the <i>style</i> is invalid, {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal} will be set instead.
 */
-(void)setStyle: (unsigned int)style;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
*									FSReadingBookmark											*
*************************************************************************************************/
    
/**
 * @brief	Class to access a reading bookmark.
 *
 * @details	Reading bookmark is not a PDF bookmark, in other words, it is not PDF outlines.
 *			It is the bookmark in applicable level. It is stored in the metadata (XML format) of catalog.
 *			It allows user to add or remove a reading bookmark according to their reading preferences and
 *			navigate one PDF page easily by selecting one reading bookmark.<br>
 *			In order to access the reading bookmark,
 *			function {@link FSPDFDoc::getReadingBookmarkCount} could be called to count the reading bookmarks,
 *			and function {@link FSPDFDoc::getReadingBookmark:} could be called to get a reading bookmark by index.
 *			This class offers several functions to access properties of reading bookmarks. For example:
 *			<ul>
 *			<li>To access the title of reading bookmark, use function {@link FSReadingBookmark::getTitle}.</li>
 *			<li>To set or rename the title, use function {@link FSReadingBookmark::setTitle:}.</li>
 *			<li>To access the page index of reading bookmark, use function {@link FSReadingBookmark::getPageIndex}.</li>
 *			<li>To set the page index, use function {@link FSReadingBookmark::setPageIndex:}.</li>
 *			</ul>
 *
 * @see	FSPDFDoc
 */
@interface FSReadingBookmark : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the title.
 *
 * @return	Title string, in UTF-8 encoding.
 *			If no title property can be found or there is any error, this function will return an empty string.
 */
-(NSString*) getTitle;

/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string. It should be UTF-8 encoding.
 */
-(void)setTitle:(NSString*)title;

/**
 * @brief	Get the index of the destination page.
 *
 * @return	The page index, starting from 0.
 *			If no page index property can be found or there is any error, this function will return -1.
 */
-(int)getPageIndex;

/**
 * @brief	Set the index of the destination page.
 *
 * @param[in]	index	The new destination page index.
 */
-(void)setPageIndex:(int)index;
/**
 * @brief	Get date and time.
 *
 * @param[in]	isCreationDate		<b>YES</b> means to get creation date time, and <b>NO</b> means to get modified date time.
 *
 * @return	The specified date and time.
 *			If no specified date and time property can be found or there is any error,
 *			this function will return a ::FSDateTime object with all values 0.
 */
-(FSDateTime *)getDateTime:(BOOL)isCreationDate;

/**
 * @brief	Set date and time.
 *
 * @param[in]	dateTime	New date and time. Its value should be valid.
 * @param[in]	isCreationDate	<b>YES</b> means to set creation date time, and <b>NO</b> means to set modified date time.
 */
-(void)setDateTime:(FSDateTime*)dateTime isCreationDate:(BOOL)isCreationDate;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *									PDF Document					  							*
 *************************************************************************************************/
/**
 * @brief	Enumeration for page label style.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PAGELABELSTYLE {
	/** @brief	Page label style: no numbering style. */
	e_pageLabelStyleNone	 =	0,
	/** @brief	Page label style: decimal Arabic numerals. */
	e_pageLabelStyleDecimalNums	=	1,
	/** @brief	Page label style: uppercase roman numerals. */
	e_pageLabelStyleUpperRomanNums	=	2,
	/** @brief	Page label style: lowercase roman numerals. */
	e_pageLabelStyleLowerRomanNums	=	3,
	/** @brief	Page label style: uppercase letters (A to Z for the first 26 pages, AA to ZZ for the next 26, and so on). */
	e_pageLabelStyleUpperLetters =	4,
	/** @brief	Page label style: lowercase letters (a to z for the first 26 pages, aa to zz for the next 26, and so on). */
	e_pageLabelStyleLowerLetters =	5
};


/**
 * @brief	Enumeration for password type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PASSWORDTYPE {
	/** @brief	The password is invalid. */
	e_pwdInvalid	 =	0,
	/** @brief	No password is used in PDF document. */
	e_pwdNoPassword	=	1,
	/** @brief	A user password is used in PDF document. */
	e_pwdUser	=	2,
	/** @brief	An owner password is used in PDF document. */
	e_pwdOwner	=	3
};


/**
 * @brief	Enumeration for encryption type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ENCRYPTTYPE {
	/** @brief	No encryption pattern. */
	e_encryptNone	 =	0,
	/** @brief	Encryption type: password, which is the standard encryption. */
	e_encryptPassword	=	1,
	/** @brief	Encryption type: digital certificate encryption. */
	e_encryptCertificate	=	2,
	/** @brief	Encryption type: Foxit DRM encryption. */
	e_encryptFoxitDRM	=	3,
	/** @brief	Encryption type: customized encryption. */
	e_encryptCustom	=	4,
	/** @brief	Encryption type: Microsoft RMS encryption. */
	e_encryptRMS	=	5
};
	
	
/**
 * @brief	Enumeration for user permissions of a PDF document.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
	
enum FS_USERPERMISSIONS {
	/**
	 * @brief	Print PDF document with normal mode. (Bit 3 in permission value)
	 * 
	 * @details	If user wants to print a higher quality level of PDF document, please set current value with {@link FS_USERPERMISSIONS::e_permPrintHigh} together.
	 */
	e_permPrint = 0x0004,
	/**
	 * @brief	Modify PDF contents. (Bit 4 in permission value)
	 * 
	 * @details	If this value is set, user can modify contents of PDF document 
	 *			by operations other than those controlled by {@link FS_USERPERMISSIONS::e_permAnnotForm}, {@link FS_USERPERMISSIONS::e_permFillForm} and {@link FS_USERPERMISSIONS::e_permAssemble} values.
	 */
	e_permModify	= 0x0008,
	/**
	 * @brief	Extract PDF contents. (Bit 5 in permission value)
	 * 
	 * @details	If this value is set, user can copy or otherwise extract text and graphics from the document 
	 *			by operations other than that controlled by {@link FS_USERPERMISSIONS::e_permExtractAccess} value. 
	 */
	e_permExtract = 0x0010,
	/**
	 * @brief	Operate text annotations and fill in interactive form fields. (Bit 6 in permission value)
	 * 
	 * @details	If {@link FS_USERPERMISSIONS::e_permModify} is also set, user can create or modify interactive form fields (including signature fields).
	 */
	e_permAnnotForm = 0x0020,
	/**
	 * @brief	Fill PDF form. (Bit 9 in permission value)
	 * 
	 * @details	If this value is set, user can fill in interactive form fields (including signature fields), 
	 * 			even if {@link FS_USERPERMISSIONS::e_permAnnotForm} is not used. 
	 */
	e_permFillForm = 0x0100,
	/** 
	 * @brief	Disabilities support. (Bit 10 in permission value)
	 * 
	 * @details	If this value is set, user can extract text and graphics in support of accessibility to users with disabilities 
	 *			or for other purposes. 
	 */
	e_permExtractAccess = 0x0200,
	/**
	 * @brief	Assemble PDF document. (Bit 11 in permission value)
	 * 
	 * @details	If this value is set, it enables to assemble the document (insert, rotate, or delete pages 
	 * 			and create bookmarks or thumbnail images), regardless if {@link FS_USERPERMISSIONS::e_permModify} is set or not. 
	 */
	e_permAssemble = 0x0400,
	/**
	 * @brief	Print PDF document with higher qualities. (Bit 12 in permission value)
	 * 
	 * @details	If this value is not set (and {@link FS_USERPERMISSIONS::e_permPrint} is set), printing is limited to a low-level 
	 * 			representation of the appearance, possibly of degraded quality. 
	 */
	e_permPrintHigh = 0x0800
};
	
	

/**
 * @brief	Class to represent information of a page labeling range.
 *
 * @details	Page label is used to identify each page visually on the screen or in print,
 *			and can be specified in any way that is appropriate for the particular document.<br>
 *			For purposes of page labeling, a document can be divided into labeling ranges,
 *			each of which is a series of consecutive pages using the same numbering system.
 *			Pages within a range are numbered sequentially in ascending order.
 *			A page's label consists of a numeric portion based on its position within its labeling range,
 *			optionally preceded by a label prefix denoting the range itself. <br>
 *			For example, the pages in an appendix might be labeled with decimal numeric portions prefixed
 *			with the string A-; the resulting page labels would be A-1, A-2, and so on.<br>
 *			This class represents the information of a page labeling range, including numbering style, label prefix
 *			and value of the numeric portion for the first page label in the range.<br>
 */
@interface FSPageLabel : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	start				The index of first page in current labeling range, starting from 0.
 * @param[in]	style				The numbering style to be used for the numeric portion of each page label.
 *									Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *									If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 * @param[in]	prefix				The label prefix string for page labels in current labeling range.
 *									Only the first 100 characters can be used as label prefix string.
 * @param[in]	firstPageNumber		The value of the numeric portion for the first page label in current labeling range.
 *									Subsequent pages are numbered sequentially from this value, which must be greater than or equal to 1.
 */
-(void)set: (int)start style: (enum FS_PAGELABELSTYLE)style prefix: (NSString *)prefix firstPageNumber: (int)firstPageNumber;
/**
 * @brief	Set the index of first page in current labeling range.
 *
 * @param[in]	value	New index for first page. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is the page count of the PDF document.
 */
-(void)setStart: (int)value;
/**
 * @brief	Get the index of first page in current labeling range.
 *
 * @return	The index for first page, starting from 0.
 */
-(int)getStart;
/**
 * @brief	Set numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 *
 * @param[in]	value	New numbering style.
 *						Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *						If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 */
-(void)setStyle: (enum FS_PAGELABELSTYLE)value;
/**
 * @brief	Get numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 *
 * @return	The numbering style.
 *			Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it would be one of these values.
 *			If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 */
-(enum FS_PAGELABELSTYLE)getStyle;
/**
 * @brief	Set label prefix.
 *
 * @param[in]	value	New label prefix string.
 *						Only the first 100 characters can be used as label prefix string.
 */
-(void)setPrefix: (NSString *)value;
/**
 * @brief	Get label prefix.
 *
 * @return	Label prefix string.
 */
-(NSString *)getPrefix;
/**
 * @brief	Set the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value,
 *			which must be greater than or equal to 1
 *
 * @param[in]	value	New value of the numeric portion.
 */
-(void)setFirstPageNumber: (int)value;
/**
 * @brief	Get the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value,
 *			which must be greater than or equal to 1
 *
 * @return	Value of the numeric portion.
 */
-(int)getFirstPageNumber;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Enumeration for PDF document saving flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SAVEFLAGS {
	/** @brief	Save document normally, without using any special flag. This can only be used alone.*/
	e_saveFlagNormal = 0,
	/**
	 * @brief	Save document incrementally. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagNoOriginal}, only the increment data will be saved.
	 */
	e_saveFlagIncremental = 0x0001,
	/**
	 * @brief	Save document without original data or unchanged objects. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagIncremental}, only the increment data will be saved.
	 */
	e_saveFlagNoOriginal = 0x0002,
	/**
	 * @brief	Save document by using object stream, in order to reduce the file size. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 */
	e_saveFlagObjectStream = 0x0004
};
	

/**
 * @brief	Class to access a PDF document.
 *
 * @details	A <CODE>PDFDoc</CODE> object can be created by following functions:
 *			<ul>
 *			<li>{@link FSPDFDoc::createFromFilePath:}: from a specified PDF file path.</li>
 *			<li>{@link FSPDFDoc::createFromMemory:}: from memory buffer which contains the serialized document.</li>
 *			<li>{@link FSPDFDoc::createFromHandler:}: from a customized <CODE>FileRead</CODE> object.</li>
 *			</ul>
 *			After a <CODE>PDFDoc</CODE> object is created, function {@link FSPDFDoc::load:} should be called to load the document content.<br>
 *			This class also offers functions to access different part of a PDF document. For example:
 *			<ul>
 *			<li>To access pages, use functions {@link FSPDFDoc::getPageCount} and {@link FSPDFDoc::getPage:}.</li>
 *			<li>To access bookmark:
 *				<ul>
 *				<li>To access bookmark tree, use function {@link FSPDFDoc::getFirstBookmark}.</li>
 *				<li>To create bookmark root node, use function {@link FSPDFDoc::createFirstBookmark}.</li>
 *				<li>To remove bookmark, use function {@link FSPDFDoc::removeBookmark:}.</li>
 *				</ul>
 *			</li>
 *			<li>To access document information (that is "metadata"), use functions {@link FSPDFDoc::hasMetadataKey:}, {@link FSPDFDoc::getCreationDateTime},
 *				{@link FSPDFDoc::getModifiedDateTime} and {@link FSPDFDoc::getMetadataValue:}.</li>
 *			<li>To access page labeling range information , use functions {@link FSPDFDoc::getPageLabelRangeCount} and {@link FSPDFDoc::getPageLabelInfo:}.
 *			</li>
 *			<li>To access document catalog dictionary (in low-level), use function {@link FSPDFDoc::getCatalog}.</li>
 *			<li>To access document trailer dictionary (in low-level), use function {@link FSPDFDoc::getTrailer}.</li>
 *			<li>To access document information dictionary (in low-level), use function {@link FSPDFDoc::getInfo}.</li>
 *			<li>To access document encrypt dictionary (in low-level), use function {@link FSPDFDoc::getEncryptDict}.</li>
 *			<li>To access reading bookmark:
 *				<ul>
 *				<li>To access the reading bookmark, use function {@link FSPDFDoc::getReadingBookmarkCount} and {@link FSPDFDoc::getReadingBookmark:}.</li>
 *				<li>To insert the reading bookmark, use function {@link FSPDFDoc::insertReadingBookmark:title:pageIndex:}.</li>
 *				<li>To remove the reading bookmark, use function {@link FSPDFDoc::removeReadingBookmark:}.</li>
 *				</ul>
 *			</li>
 *			<li>To access interactive form, use functions {@link FSPDFDoc::hasForm} and {@link FSPDFDoc::getForm}.</li>
 *			</ul>
 *
 * @see	FSPDFPage
 * @see	FSBookmark
 * @see	FSPageLabel
 * @see	FSPDFDictionary
 * @see	FSReadingBookmark
 */
@interface FSPDFDoc : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a PDF document object with an existing PDF document from file path.
 *
 * @param[in]	path	Path name of the PDF file.
 *
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromFilePath: (NSString *)path;
/**
 * @brief	Create a PDF document object with a memory buffer.
 *
 * @param[in]	buffer		A memory buffer, containing the serialized document.
 *							The PDF document data should be fully loaded in the memory buffer.<br>
 *							The memory buffer ownership is not transferred to the PDF document object,
 *							so when the document is not used any more, user should clean-up allocated memory if necessary.
 *
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromMemory: (NSData *)buffer;
/**
 * @brief	Create a document object with a file read instance.
 *
 * @param[in]	fileRead	A file read instance which is implemented by user to load a PDF document.
 *
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromHandler: (FSFileReadCallback*)fileRead;
/**
 * @brief	Load current document content by using the specified password.
 *
 * @param[in]	password		The password string, used to load current document content. It can be either user password or owner password.
 *								If current document is not encrypted by password, just pass an empty string.
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success. <br>
 *			{@link FS_ERRORCODE::e_errFile} means there is any error occurs when accessing to current document content.<br>
 *			{@link FS_ERRORCODE::e_errFormat} means the format of current document content is not PDF or the file is corrupted.<br>
 *			{@link FS_ERRORCODE::e_errSecurityHandler} means current PDF document is encrypted by some unsupported security handler.<br>
 *			{@link FS_ERRORCODE::e_errCertificate} means current PDF document is encrypted by digital certificate and current user does not have the correct certificate. <br>
 *			For other error code value, please refer to {@link FS_ERRORCODE::e_errSuccess FS_ERRORCODE::e_errXXX} for more details.
 */
-(enum FS_ERRORCODE)load: (NSString *)password;
/**
 * @brief	Check whether current document is an encrypted file or not.
 *
 * @return	<b>YES</b> means current document is an encrypted file, while <b>NO</b> means current document is not an encrypted file.
 */
-(BOOL)isEncrypted;
/**
 * @brief	Check whether current document has been modified or not.
 *
 * @details	Once function {@link FSPDFDoc::saveAs:saveFlags:} is called successfully, the modified status of current document will be <b>FALSE</b> until the document is be modified again.
 *
 * @return	<b>YES</b> means current document has been modified, while <b>NO</b> means current document has not been modified.
 */
-(BOOL)isModified;
/**
 * @brief	Get the encryption type.
 *
 * @return	Encryption type.
 *			Please refer to {@link FS_ENCRYPTTYPE::e_encryptNone FS_ENCRYPTTYPE::e_encryptXXX} values and it would be one of these values.
 */
-(enum FS_ENCRYPTTYPE)getEncryptionType;
/**
 * @brief	For the password protected document, get the type of password, which is used when loading document content in function {@link FSPDFDoc::load:}.
 *
 * @return	Password type.
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)getPasswordType;
/**
 * @brief	For the password protected document, check the type of a specified password.
 *
 * @details	This function can be used to check the type of any password string.
 *
 * @param[in]	password		The password string to be checked.
 *
 * @return	Password type.
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)checkPassword: (NSString *)password;
/**
 * @brief	Save current PDF document as another PDF file.
 *
 * @param[in]	filePath		File path for the new saved PDF file.
 * @param[in]	saveFlags		Document saving flags.
 *								Please refer to {@link FS_SAVEFLAGS::e_saveFlagNormal FS_SAVEFLAGS::e_saveFlagXXX} values and this can be one or combination of these values.
 *
 * @return	<b>YES</b> means the saving is successfully finished, while <b>NO</b> means failure.
 */
-(BOOL)saveAs: (NSString *)filePath saveFlags:(unsigned int)saveFlags;
/**
 * @brief	Create new bookmark root node.
 *
 * @details	If current PDF document already has the bookmark root node, this function will remove the old bookmark tree
 *			and create a new root node instead.
 *
 * @return	A ::FSBookmark object that represents the root bookmark.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSBookmark*) createFirstBookmark;
/**
 * @brief	Remove a specified bookmark.
 *
 * @param[in]	bookmark	The bookmark that would be deleted.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeBookmark:(FSBookmark*) bookmark;
/**
 * @brief	Get the first bookmark.
 *
 * @return	The first bookmark.
 */
-(FSBookmark*)getFirstBookmark;
/**
 * @brief	Get the count of pages.
 *
 * @return	The count of page.
 */
-(int)getPageCount;
/**
 * @brief	Get a PDF page by index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	A PDF page instance.
 *			If the page instance is not used any more, please call function {@link FSPDFDoc::closePage:} to close it.
 */
-(FSPDFPage*)getPage: (int)pageIndex;
/**
 * @brief	Close a PDF page by page index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)closePage: (int)pageIndex;
/**
 * @brief	Get the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @return	Display mode value.
 *			Please refer to {@link FS_DISPLAYMODE::e_displayUseNone FS_DISPLAYMODE::e_displayUseXXX} values and this would be one of its values.
 */
-(enum FS_DISPLAYMODE)getDisplayMode;
/**
 * @brief	Get the catalog dictionary.
 *
 * @return	The catalog dictionary.
 */
-(FSPDFDictionary*)getCatalog;
/**
 * @brief	Get the trailer dictionary.
 *
 * @return	The trailer dictionary.
 */
-(FSPDFDictionary*)getTrailer;
/**
 * @brief	Get the information dictionary.
 *
 * @details	Document's information dictionary contains metadata for the document.
 *
 * @return	The information dictionary.
 */
-(FSPDFDictionary*)getInfo;
/**
 * @brief	Get the encrypt dictionary.
 *
 * @return	The encrypt dictionary.
 */
-(FSPDFDictionary*)getEncryptDict;
/**
 * @brief	Get an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @return	A ::FSPDFObject object that receives the indirect PDF object.
 *			<b>nil</b> means not found or there is any error.
 */
-(FSPDFObject*)getIndirectObject: (unsigned int)objnum;
/**
 * @brief	Add a PDF object to current PDF document, to be an indirect object.
 *
 * @details	<ul>
 *			<li>If input PDF object is a direct object (whose indirect object number is 0),
 *				this functions will change it to be an indirect object and add to PDF document.
 *				Then return the new indirect object number.</li>
 *			<li>If input PDF object is already an indirect object (whose indirect object number is above 0),
 *				this function will not add it into document again.
 *				The return value will be its own indirect object number.</li>
 *			</ul>
 *
 * @param[in]	obj		A PDF object instance.
 *
 * @return	The new indirect object number.
 *			If there is any error, 0 will be returned.
 */
-(unsigned int)addIndirectObject: (FSPDFObject*)obj;
/**
 * @brief	Delete an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 */
-(void)deleteIndirectObject: (unsigned int)objnum;
/**
 * @brief	Get user access permissions.
 *
 * @return	User access permission.
 *			Please refer to {@link FS_USERPERMISSIONS::e_permPrint FS_USERPERMISSIONS::e_permXXX} values and this would be one or combination of its values.
 */
-(unsigned int)getUserPermissions;
/**
 * @brief	Check whether current document has a specified metadata key or not.
 *
 * @param[in]	key		The metadata key to be confirmed.
 *
 * @return	<b>YES</b> means current document has the specified metadata key,
 *			while <b>NO</b> means current document does not have the specified metadata key.
 */
-(BOOL)hasMetadataKey: (NSString *)key;
/**
 * @brief	Get creation date time.
 *
 * @return	The creation date time.
 *			If no creation date time can be found or any error occurs, <b>nil</b> will be returned.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Get modified date time.
 *
 * @return	The modified date time.
 *			If no modified date time can be found or any error occurs, <b>nil</b> will be returned.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Get metadata value.
 *
 * @param[in]	key		Metadata key string. Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li>
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						</ul>
 *
 * @return	Metadata value string.
 */
-(NSString *)getMetadataValue: (NSString *)key;
/**
 * @brief	Get count of ranges of page labels, which use different numbering systems.
 *
 * @return	The count of the page label range.
 */
-(int)getPageLabelRangeCount;
/**
 * @brief	Get information of a specified page label.
 *
 * @param[in]	index		The index of the page label range to get the information.
 *							Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageLabelRangeCount}.
 *
 * @return	The page label information.
 *			If any error occurs, <i>nil</i> will be returned.
 */
-(FSPageLabel*)getPageLabelInfo: (int)index;

/**
 * @brief	Check whether current PDF document has interactive form (also known as AcroForm).
 *
 * @return	<b>YES</b> means current document has interactive form.
 *			<b>NO</b> means current document does not have interactive form.
 */
-(BOOL)hasForm;

/**
 * @brief	Get the interactive form object.
 *
 * @return	A ::FSForm object that represents the interactive form.
 *			If current document does not have interactive form or there is any error, this function will return <b>nil</b>.
 */
-(FSForm*)getForm;

/**
 * @brief	Get the count of reading bookmarks.
 *
 * @return	The count of reading bookmarks.
 */
-(int)getReadingBookmarkCount;

/**
 * @brief	Get a reading bookmark by index.
 *
 * @param[in]	index	The index of reading bookmarks. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFDoc::getReadingBookmarkCount}.
 *
 * @return	The reading bookmark object with speicified index.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSReadingBookmark*)getReadingBookmark:(int)index;

/**
 * @brief	Insert a reading bookmark to current PDF document.
 *
 * @param[in]	readingBookmarkIndex	The reading bookmark index.<br>
 *										If <i>readingBookmarkIndex</i> is less than 0, the new reading bookmark will be inserted to the first.
 *										If <i>readingBookmarkIndex</i> is equal or larger than the count of reading bookmarks,
 *										the new reading bookmark will be inserted to the end.
 * @param[in]	title					Title string for new reading bookmark. It should be UTF-8 encoding.
 * @param[in]	destPageIndex			The destination page index.
 *
 * @return	A new reading bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSReadingBookmark*)insertReadingBookmark: (int)readingBookmarkIndex title:(NSString*)title pageIndex:(int)destPageIndex;

/**
 * @brief	Remove a reading bookmark from current PDF document.
 *
 * @param[in]	readingBookmark	The reading bookmark to be removed.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeReadingBookmark:(FSReadingBookmark*)readingBookmark;

/**
 * @brief	Get the count of signature.
 *
 * @return	The count of signature.
 */
-(int)getSignatureCount;

/**
 * @brief	Get a signature by index.
 *
 * @param[in]	index	The index of signature. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function FSPDFDoc::getSignatureCount.
 *
 * @return	The signature object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSSignature*)getSignature: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Enumeration for PDF object type.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_PDFOBJECTTYPE {
	/** @brief	Invalid PDF object type. */
	e_objInvalidType = 0,
	/** @brief	PDF object type for boolean. */
	e_objBoolean = 1,
	/** @brief	PDF object type for number. */
	e_objNumber = 2,
	/** @brief	PDF object type for string. */
	e_objString = 3,
	/** @brief	PDF object type for name. */
	e_objName = 4,
	/** @brief	PDF object type for array. */
	e_objArray = 5,
	/** @brief	PDF object type for dictionary. */
	e_objDictionary = 6,
	/** @brief	PDF object type for stream. */
	e_objStream = 7,
	/** @brief	PDF object type for a null object. */
	e_objNull = 8,
	/** @brief	PDF object type for a reference object. */
	e_objReference = 9
};
	

/**
 * @brief	Class to access a PDF object.
 *
 * @details	PDF supports eight basic types of objects: <br>
 *			"Boolean value", "Integer and real number", "String", "Name",
 *			"Array", "Dictionary",  "Stream", "The null object".<br>
 *			If user wants to make a newly created PDF object to be an indirect object, please call function {@link FSPDFDoc::addIndirectObject:}.
 *			For more details about PDF objects, please refer to <PDF Reference 1.7> Section 3.2 Objects.<br>
 *			Class ::FSPDFObject is a base class for all kinds of PDF objects. It offers different functions to create different kind of PDF objects.
 *			For "Array", "Dictionary" and "Stream" PDF object, please refer to derived classes ::FSPDFArray, ::FSPDFDictionary and ::FSPDFStream.
 *
 * @see FSPDFArray
 * @see FSPDFDictionary
 * @see FSPDFStream
 */
@interface FSPDFObject : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a PDF object from a boolean value.
 *
 * @param[in]	boolean		A boolean value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 */
+(FSPDFObject*)createFromBoolean: (BOOL)boolean;
/**
 * @brief	Create a PDF object from a float number.
 *
 * @param[in]	f		A float value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
+(FSPDFObject*)createFromFloat: (float)f;
/**
 * @brief	Create a PDF object from a integer number.
 *
 * @param[in]	integer		An integer value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
+(FSPDFObject*)createFromInteger: (int)integer;
/**
 * @brief	Create a PDF object from string.
 *
 * @param[in]	string	A string value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objString}.
 */
+(FSPDFObject*)createFromString: (NSString *)string;
/**
 * @brief	Create a PDF object from a string which represents a name.
 *
 * @param[in]	name	A name string.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objName}.
 */
+(FSPDFObject*)createFromName: (NSString *)name;
/**
 * @brief	Create a PDF object from date time.
 *
 * @details	PDF defines a standard date format, which closely follows that of the
 *			international standard ASN.1 (Abstract Syntax Notation One), defined in ISO/
 *			IEC 8824 (see the Bibliography). A date is an ASCII string of the form
 *			(D:YYYYMMDDHHmmSSOHH'mm')
 *
 * @param[in]	dateTime	A date time instance.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objString}.
 */
+(FSPDFObject*)createFromDateTime: (FSDateTime*)dateTime;
/**
 * @brief	Create a reference for an indirect object.
 *
 * @details	The indirect object can be retrieved from following functions:
 *			<ul>
 *			<li>Returned by function {@link FSPDFDoc::getIndirectObject:}.</li>
 *			<li>Returned by function {@link FSPDFDoc::addIndirectObject:}, when try to add a direct PDF object to PDF document
 *				and make it to be an indirect object.</li>
 *			</ul>
 *
 * @param[in]	pDoc	A PDF document instance.
 * @param[in]	objnum	The indirect object number of the indirect PDF object. This should be above 0.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objReference}.
 */
+(FSPDFObject*)createReference: (FSPDFDoc*)pDoc objnum: (unsigned int)objnum;
/**
 * @brief	Clone current PDF object and get the clone result.
 *
 * @return	A new PDF object instance as the clone result.
 */
-(FSPDFObject*)cloneObject;
/**
 * @brief	Get the type of current PDF object.
 *
 * @return	A value represents the object type. Please refer to {@link FS_PDFOBJECTTYPE::e_objBoolean FS_PDFOBJECTTYPE::e_objXXX} values and it would be one of these values.
 */
-(enum FS_PDFOBJECTTYPE)getType;
/**
 * @brief	Get the indirect object number of current PDF object.
 *
 * @return	The indirect object number:
 *			<ul>
 *			<li>0 for direct object.</li>
 *			<li>above 0 for indirect object.</li>
 *			<li>-1 means there is any error.</li>
 *			</ul>
 */
-(unsigned int)getObjNum;
/**
 * @brief	Get the integer value of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 *
 * @return	The integer value. -1 may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
-(int)getInteger;
/**
 * @brief	Get the float value of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 *
 * @return	The integer value. -1.0 may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
-(float)getFloat;
/**
 * @brief	Get the boolean value of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 *
 * @return	The boolean value. <b>NO</b> may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 */
-(BOOL)getBoolean;
/**
 * @brief	Get the matrix value of current PDF object.
 *
 * @details	Only used for a PDF array object when it has 6 number objects as elements.
 *
 * @return	A matrix instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSMatrix*)getMatrix;
/**
 * @brief	Get the rectangle value of current PDF object.
 *
 * @details	Only used for a PDF array object when it has 4 number objects as elements.
 *
 * @return	A float rectangle instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getRect;
/**
 * @brief	Get the direct object of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objReference}.
 *
 * @return	A PDF object that represents the direct PDF object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getDirectObject;
/**
 * @brief	Get the date time value of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objString} and its content is PDF standard date format.
 *
 * @return	A date time instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSDateTime*)getDateTime;
/**
 * @brief	Get the string value of current PDF object.
 *
 * @details	This function will get the string format for actual value of current PDF object.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}, "true" or "false" string value will be returned, depending on its actual value.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objNumber}, the value will be represents as a string. For example, "1.5" string is for value 1.5.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objString} or {@link FS_PDFOBJECTTYPE::e_objName}, the string value will be retrieved directly.<br>
 *			If value of current PDF object cannot be converted to a valid string, an empty string will be returned.
 *
 * @return	String value.
 *			An empty string may also mean there is not valid string value or there is any error.
 */
-(NSString *)getString;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a PDF stream object.
 *
 * @details	A PDF stream object consists of a direct dictionary object and stream data.<br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.7 Stream Objects.<br>
 *			Class ::FSPDFStream is derived from ::FSPDFObject
 *			and offers functions to create a new PDF stream object and access stream data.
 *
 * @see FSPDFObject
 */
@interface FSPDFStream : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new stream object based on a dictionary.
 *
 * @param[in]	dictionary	A PDF dictionary object.
 *							If this is <b>nil</b>, stream object will be created based on an empty dictionary.
 *
 * @return	A new PDF stream object.
 */
+(FSPDFStream*)create: (FSPDFDictionary*)dictionary;
/**
 * @brief	Get the dictionary object associated to current stream object.
 *
 * @return	The stream dictionary.
 */
-(FSPDFDictionary*)getDictionary;
/**
 * @brief	Get size of stream data, in bytes.
 *
 * @param[in]	rawData		A boolean value that indicates whether to get raw data or not:
 *							<b>YES</b> means to get raw data, and <b>NO</b> means to get decoded data (original data).
 *
 * @return	The data size, in bytes.
 */
-(unsigned int)getDataSize: (BOOL)rawData;
/**
 * @brief	Get stream data.
 *
 * @param[in]	rawData		A boolean value that indicates whether to get raw data or not:
 *							<b>YES</b> means to get raw data, and <b>NO</b> means to get decoded data (original data).
 * @param[in]	bufLen		Size of the data that user wants to retrieve from current PDF stream object, in bytes.
 *							If this is larger than the actual stream data size returned by function {@link FSPDFStream::getDataSize:} (with same parameter <i>rawData</i>),
 *							the whole stream data will be retrieved.
 *
 * @return	Stream data.
 */
-(NSData *)getData: (BOOL)rawData bufLen: (int)bufLen;
/**
 * @brief	Set stream data.
 *
 * @param[in]	buffer		New stream data.
 */
-(void)setData: (NSData *)buffer;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a PDF array object.
 *
 * @details	A PDF array object is a one-dimensional collection of objects arranged sequentially.
 *			Unlike arrays in many other computer languages, elements in a PDF array can be any combination of numbers, strings,
 *			dictionaries, or any other objects, including other arrays. <br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.5 Array Objects.<br>
 *			Class ::FSPDFArray is derived from ::FSPDFObject
 *			and offers functions to create a new PDF array object and access elements of a PDF array object.
 *
 * @see FSPDFObject
 */
@interface FSPDFArray : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new array object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)create;
/**
 * @brief	Create a new array object for a matrix.
 *
 * @param[in]	matrix	A matrix object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)createFromMatrix: (FSMatrix*)matrix;
/**
 * @brief	Create a new array object for a rectangle.
 *
 * @param[in]	rect	A float rectangle object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)createFromRect: (FSRectF*)rect;
/**
 * @brief	Get the count of elements.
 *
 * @return	Count of elements. If there is any error, -1 will be returned.
 */
-(int)getElementCount;
/**
 * @brief	Get a specific element by index.
 *
 * @param[in]	index	Index of the element to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 *
 * @return	A ::FSPDFObject object receives the element.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getElement: (int)index;
/**
 * @brief	Add a PDF object to the end of current PDF array object.
 *
 * @param[in]	element		The PDF object to be added to array.
 */
-(void)addElement: (FSPDFObject*)element;
/**
 * @brief	Insert a PDF object to a specific position of current PDF array object.
 *
 * @param[in]	index		Index of the position where parameter <i>element</i> will be inserted to.
 *							Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 *							If this is below 0 or count of element in current PDF array is 0, parameter <i>element</i> is to be inserted to the first position.<br>
 *							If this is larger than count of element in current PDF array, parameter <i>element</i> is to be added to the last.
 * @param[in]	element		The PDF object to be inserted to current PDF array.
 */
-(void)insertAt: (int)index element: (FSPDFObject*)element;
/**
 * @brief	Set a new PDF object at specific position in current PDF array object.
 *
 * @param[in]	index		Index of the position where parameter <i>element</i> will be set to.
 *							Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 * @param[in]	element		The PDF object to be set to current PDF array.
 */
-(void)setAt: (int)index element: (FSPDFObject*)element;
/**
 * @brief	Remove an element in a specific position(by index) from current PDF array object.
 *
 * @param[in]	index	Index of the position where the element will be removed.
 *						Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 */
-(void)removeAt: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a PDF dictionary object.
 *
 * @details	A PDF dictionary object is an associative table containing pairs of objects, known as entries of the dictionary.
 *			The first element of each entry is the key, and it must be a name PDF object.
 *			The second element is the value, and it can be any kind of PDF object, including another dictionary.
 *			In the same dictionary, no two entries should have the same key. <br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.6 Dictionary Objects.<br>
 *			Class ::FSPDFDictionary is derived from ::FSPDFObject
 *			and offers functions to create a new PDF dictionary object and access entries in a PDF dictionary object.
 *
 * @see FSPDFObject
 */
@interface FSPDFDictionary : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new dictionary object.
 *
 * @return	A new PDF dictionary instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objDictionary}.
 */
+(FSPDFDictionary*)create;
/**
 * @brief	Check whether there is an entry with specific key in current dictionary or not.
 *
 * @param[in]	key		The key to be checked.
 *
 * @return	<b>YES</b> means the specific key exist in current dictionary, while <b>NO</b> means not.
 *			<b>NO</b> may also mean there is any error.
 */
-(BOOL)hasKey: (NSString *)key;
/**
 * @brief	Get the value element of an entry with specific key.
 *
 * @param[in]	key		The key of the entry.
 *
 * @return	A PDF object instance that represents the value element of the specific entry.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getElement: (NSString *)key;
/**
 * @brief	Get the key of an entry specified by position.
 *
 * @param[in]	pos		A position instance that specifies the position of the entry.
 *
 * @return	The key of the specific entry.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getKey: (void*)pos;
/**
 * @brief	Get the value element of an entry specified by position.
 *
 * @param[in]	pos		A position object that specifies the position of the entry.
 *
 * @return	A PDF object instance that receives the value element of the specific entry.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getValue: (void*)pos;
/**
 * @brief	Move to the position of first or the next entry.
 *
 * @param[in]	pos		A position instance that indicates the position of current entry in the dictionary.
 *						If this is <b>nil</b>, the position of first entry in the dictionary will be returned.
 *
 * @return	A new position instance that represents the position of next entry in the dictionary.
 *			<b>nil</b> means current entry is the last in the dictionary, or there is any error.
 */
-(void*)moveNext: (void*)pos;
/**
 * @brief	Set a PDF object as value element to an entry with specific key.
 *
 * @param[in]	key		The key of the entry, whose value element will be set.
 * @param[in]	object	A PDF object instance which will be set to the entry as value element.
 */
-(void)setAt: (NSString *)key object: (FSPDFObject*)object;
/** 
 * @brief	Remove an entry with specific key.
 *
 * @param[in]	key		The key of the entry to be removed.
 */
-(void)removeAt: (NSString *)key;

/** @brief Free the object. */
-(void)dealloc;

@end
	
	

/** 
 * @brief	Enumeration for Page parse status.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_PAGEPARSEFLAG {
	/** @brief	PDF page parsing flag for normal mode. */
	e_parsePageNormal = 0x0000,
	/** @brief	PDF page parsing flag for text-only mode. */
	e_parsePageTextOnly = 0x0001,
	/** @brief	Parse the text content of PDF page with outputting the hyphen on a line feed.*/
	e_parseTextOutputHyphen = 0x0002
};

/** 
 * @brief	Enumeration for calculating margin mode.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_CALCMARGINMODE {
	/** @brief	Calculate margin according to bounding box of all contents. */
	e_calcContentsBox = 0,
	/** @brief	Calculate margin by detecting paths or images. */
	e_calcDetection = 1
};

/**
 * @brief	Class to access a PDF page.
 *
 * @details	Usually, a ::FSPDFPage object is retrieved from a PDF document by function {@link FSPDFDoc::getPage:}
 *			Function {@link FSPDFPage::isParsed} is used to judge whether the PDF page has been parsed or not.
 *			For a un-parsed page, use function {@link FSPDFPage::startParse:pause:isReparse:} to parse it.<br>
 *			This class offers functions to access data of a PDF page, such as page width/height, page rotation, display matrix and so on.
 *			It also offers functions to access PDF annotations:
 *			<ul>
 *			<li>To get a PDF annotation, use function {@link FSPDFPage::getAnnot:}, {@link FSPDFPage::getAnnotAtPos:tolerance:},
 *				or {@link FSPDFPage::getAnnotAtDevicePos:position:tolerance:}.</li>
 *			<li>To add a new PDF annotation, use function {@link FSPDFPage::addAnnot:rect:}.</li>
 *			<li>To remove a PDF annotation, use function {@link FSPDFPage::removeAnnot:}.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 * @see FSAnnot
 */
@interface FSPDFPage : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the PDF document, which current PDF page belongs to.
 *
 * @return	Related PDF document.
 */
-(FSPDFDoc*)getDocument;
/**
 * @brief	Get the page dictionary.
 *
 * @return	Page dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getDict;
/**
 * @brief	Check if current page has been parsed or not.
 *
 * @return	<b>YES</b> means current page has been parsed, while <b>NO</b> means current page has not been parsed yet.
 */
-(BOOL)isParsed;
/**
 * @brief	Start to parse current page.
 *
 * @param[in]	flag		Parsing flag.
 *							Please refer to {@link FS_PAGEPARSEFLAG::e_parsePageNormal FS_PAGEPARSEFLAG::e_parsePageXXX} values and this should be one or a combination of these values.
 * @param[in]	pause		A pause instance (which is implemented by user) to decide if the parsing process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the parsing process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	isReparse	<b>YES</b> means to re-parse current page, while <b>NO</b> means do not re-parse current page.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startParse: (unsigned int)flag pause: (FSPauseCallback*)pause isReparse: (BOOL)isReparse;
/**
 * @brief	Continue to parse the page if the parsing process has not been finished yet.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueParse;
/**
 * @brief	Get page index.
 *
 * @return	Page index, starting from 0.
 */
-(int)getIndex;
/**
 * @brief	Get the page height.
 *
 * @return	Page height.
 */
-(float)getHeight;
/**
 * @brief	Get the page width.
 *
 * @return	Page width
 */
-(float)getWidth;
/**
 * @brief	Get the page rotation.
 *
 * @return	Page rotation value.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 */
-(enum FS_ROTATION)getRotation;
/**
 * @brief	Load the thumbnail bitmap.
 *
 * @return	Thumbnail bitmap.<br>
 *			If no thumbnail can be found or there is any error, this function will return <b>nullptr</b>.<br>
 */
-(FSBitmap*)loadThumbnail;
/**
 * @brief	Get the display matrix of PDF page, from PDF coordinate system to targeted device coordinate system.
 *
 * @param[in]	xPos	Left position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	yPos	Top position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	xSize	Width of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	ySize	Height of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	rotate	Rotation value.
 *						Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 *
 * @return	Display matrix.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSMatrix*)getDisplayMatrix: (int)xPos yPos: (int)yPos xSize: (int)xSize ySize: (int)ySize rotate: (enum FS_ROTATION)rotate;
/**
 * @brief	Calculate the content area of PDF page.
 *
 * @param[in]	mode	Calculation mode. It should be one of following values:
 *						<ul>
 *						<li>{@link FS_CALCMARGINMODE::e_calcContentsBox} means calculate margin according to bounding box of all contents.</li>
 * 						<li>{@link FS_CALCMARGINMODE::e_calcDetection} means calculate margin by detecting paths or images.</li>
 *						</ul>
 *
 * @return	The minimal rectangle which contains the visible page content.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(FSRectF*)calcContentBBox: (enum FS_CALCMARGINMODE)mode;
/**
 * @brief	Get the count of annotations.
 *
 * @return	The count of the annotations.
 */
-(int)getAnnotCount;
/**
 * @brief	Get an annotation by index.
 *
 * @param[in]	index	Annotation index. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPage::getAnnotCount}.
 *
 * @return	An annotation instance.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnot: (int)index;
/**
 * @brief	Get the annotation at a specific position, in PDF coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	pos			The specific position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnotAtPos: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Get the annotation at a specific position, in device coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	matrix		The transformation matrix. Usually this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, current function will have the same feature as function {@link FSPDFPage::getAnnotAtPos:tolerance:}.
 * @param[in]	pos			The specific position, in device coordinate system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnotAtDevicePos:(const FSMatrix*)matrix position: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Add an annotation to PDF page.
 *
 * @details	Currently, this function can support to add most annotation types except:<br>
 *			Widget, Sound, Movie, Screen, PrinterMark, TrapNet, Watermark, 3D, PSInk.<br>
 *			Attention:
 *			<ul>
 *			<li>Specially, widget annotations are used to represent as form controls of form field, including signature field. <br>
 *				For signature field, function {@link FSPDFPage::addSignature:} can be called to add a new signature object. <br>
 *				For other types of form field, not support to add them yet.<br>
 *			</li>
 *			<li>For supported annotations types, if user does not set any properties of the newly created annotation (except the required properties)
 *				and directly calls function {@link FSAnnot::resetAppearanceStream}, default appearance will be used.
 *				Please refer to comment of concrete annotation class for more details of their own default appearance.
 *			</li>
 *			</ul>
 *
 * @param[in]	annotType	The type of annotation to be added.
 *							Currently, only support:<br>
 *							{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline},
 *							{@link FSM_ANNOTTYPE::e_annotSquiggly}, {@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotLink},
 *							{@link FSM_ANNOTTYPE::e_annotSquare}, {@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText},
 *							{@link FSM_ANNOTTYPE::e_annotStamp}, {@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotInk},
 *							{@link FSM_ANNOTTYPE::e_annotLine}, {@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine},
 *							{@link FSM_ANNOTTYPE::e_annotFileAttachment}, {@link FSM_ANNOTTYPE::e_annotPopup}.
 * @param[in]	rect		Rectangle of the new annotation.
 *							<ul>
 *							<li>For annotation in following type, they needs a valid rectangle when being added. So for them, <i>rect</i> should be valid:<br>
 *								{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotLink}, {@link FSM_ANNOTTYPE::e_annotSquare},
 *								{@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText}, {@link FSM_ANNOTTYPE::e_annotStamp},
 *								{@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotFileAttachment}.</li>
 *							<li>For annotation in following type, their rectangle will be updated when other required properties of them have been set.
 *								So for them, <i>rect</i> can be an empty rectangle:<br>
 *								{@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline}, {@link FSM_ANNOTTYPE::e_annotSquiggly},
 *								{@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotInk}, {@link FSM_ANNOTTYPE::e_annotLine},
 *								{@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine}, {@link FSM_ANNOTTYPE::e_annotPopup}.<br>
 *								If an invalid rectangle is passed to <i>rect</i>, an empty rectangle will be used instead.</li>
 *							</ul>
 *
 * @return	A ::FSAnnot object that receives the newly created annotation.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSAnnot*)addAnnot: (enum FS_ANNOTTYPE)annotType rect: (FSRectF*)rect;
/**
 * @brief	Remove an annotation.
 *
 * @param[in]	annot	An annotation to be removed. It should be in current PDF page.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAnnot: (FSAnnot*)annot;
/**
 * @brief	Check whether current PDF page has transparency or not.
 *
 * @return	<b>YES</b> means current page has transparency, while <b>NO</b> means current page does not have transparency.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(BOOL)hasTransparency;

/**
 * @brief	Flatten current PDF page: annotations or form fields may be made to be a part of the page contents according to specified options.
 *
 * @details     After flattening current page successfully, user should re-parse this page by function {@link FSPDFPage::startParse:pause:isReparse:}.
 *
 * @param[in]	isDisplay	The flatten flags:
 *							<b>YES</b> means the flatten result is used for display, and <b>NO</b> means the flatten result is used for print.
 * @param[in]	options		The flatten options.
 *							Please refer to {@link FS_FLATTENOPTIONS::e_flattenOptionAll FS_FLATTENOPTIONS::e_flattenOptionXXX} values and it should one
 *                                  or a combination of them.<br>
 *							Specially, if {@link FS_FLATTENOPTIONS::e_flattenOptionNoAnnot} and {@link FS_FLATTENOPTIONS::e_flattenOptionNoFormControl}
 *                                  are used together,
 *							that means nothing is to be flatten to page and this function will return <b>YES</b> directly.
 *
 * @return	<b>YES</b> means current page is flattened successfully, while <b>NO</b> means failure.
 */
-(BOOL)flatten:(BOOL)isDisplay options:(unsigned int)options;
/**
 * @brief	Group all the input markup annotations together.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in the group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @param[in]	annotArray		A markup annotation object array that specifies markup annotations which are to be grouped together.
 *								This array should contains at least 2 markup annotations, and all the markup annotations in this array should be different from others.
 *								All the markup annotations in this array should be in current page. <br>
 *								Specially, if a markup annotation in this array is already in another group, that group will be set to the new group with the new header as well.
 * @param[in]	headerIndex		The index that specifies a markup annotation in parameter <i>annotArray</i> to be the header of the group.
 *								Valid range: from 0 to (<i>arrayCount</i> -1).
 *
 * @return	<b>YES</b> means group input markup annotations together successfully,
 *			while <b>NO</b> means failure.
 */
-(BOOL)setAnnotGroup: (NSArray<FSMarkup*>*)annotArray  headerIndex: (int)headerIndex;

/**
 * @brief	Add a signature to PDF page.
 *
 * @param[in]	rect		Rectangle position for the new signature, in PDF coordinate system.
 *
 * @return	A ::FSSignature object that receives the newly created signature.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSSignature*)addSignature: (FSRectF*)rect;

/** @brief Free the object. */
-(void)dealloc;

@end


/************************************************************************************************
 *									Render   													*
 *************************************************************************************************/

/**
 * @brief	Class to access a bitmap.
 *
 * @details	Bitmap is one of most important data structures in Foxit PDF SDK.
 *			It is commonly used for rendering.
 */
@interface FSBitmap : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a bitmap.
 *
 * @details	If the parameter <i>buffer</i> is not <b>nil</b>, it should be initialized by application;
 *			otherwise, Foxit PDF SDK will allocate and initialize the pixels buffer internally. <br>
 *			Application is suggested to use the same colors to initialize bitmap' pixels buffer as Foxit PDF SDK uses internally:
 *			<ul>
 *			<li>For the bitmap without alpha channel, initialize the pixels buffer with 0xFFFFFFFF.</li>
 *			<li>For the bitmap with alpha channel, initialize the pixels buffer with 0x00000000.</li>
 *			</ul>
 *
 * @param[in]	width		Width of a bitmap, in pixels. This should be above 0.
 * @param[in]	height		Height of a bitmap, in pixels. This should be above 0.
 * @param[in]	format		Bitmap format type. It should be one of {@link FS_DIBFORMAT::e_dibRgb}, {@link FS_DIBFORMAT::e_dibRgb32} and {@link FS_DIBFORMAT::e_dibArgb}.
 * @param[in]	buffer		A buffer that specifies bitmap data.<br>
 *							If it is not <b>nil</b>, this function will use the parameter <i>buffer</i> to initialize a bitmap.
 *							Please keep the buffer valid during the life-cycle of the bitmap.<br>
 * 							If it is <b>nil</b>, a new bitmap buffer will be created internally.
 * @param[in]	pitch		The number of bytes for each scan line and only useful when parameter <i>buffer</i> is used.
 *							If 0, 4-byte alignment is assumed.
 *
 * @return	A new bitmap instance.
 */
+(FSBitmap*)create: (int)width height: (int)height format: (enum FS_DIBFORMAT)format buffer: (unsigned char *)buffer pitch: (int)pitch;
/**
 * @brief	Clone current bitmap, with specified clip rectangle.
 *
 * @param[in]	clip	The clipping region in current bitmap, which is to be cloned.
 *						This can be <b>nil</b> to clone the whole bitmap.
 *						If this is not <b>nil</b>, it specifies a clipping region in bitmap to be cloned
 *						and the cloned bitmap will have the same size as the clipping region.
 *
 * @return	A new bitmap instance as clone result.
 */
-(FSBitmap*)clone: (FSRectI*)clip;
/**
 * @brief	Get bitmap width.
 *
 * @return	Bitmap width.
 *			If any error occurs, -1 will be returned.
 */
-(int)getWidth;
/**
 * @brief	Get bitmap height.
 *
 * @return	Bitmap height.
 *			If any error occurs, -1 will be returned.
 */
-(int)getHeight;
/**
 * @brief	Get bitmap pitch.
 *
 * @return	Bitmap pitch.
 *			If any error occurs, -1 will be returned.
 */
-(int)getPitch;
/**
 * @brief	Get bitmap bits-per-pixel.
 *
 * @return	Bitmap bits-per-pixel value.
 *			If any error occurs, -1 will be returned.
 */
-(int)getBpp;
/**
 * @brief	Get bitmap buffer.
 *
 * @return	Bitmap buffer data.
 *			If any error occurs, <b>nil</b> will be returned.
 */
-(NSData *)getBuffer;
/**
 * @brief	Get bitmap format.
 *
 * @return	Format value.
 *			Please refer to {@link FS_DIBFORMAT::e_dibInvalid FS_DIBFORMAT::e_dibXXX} values and this would be one of these values.
 */
-(enum FS_DIBFORMAT)getFormat;
/**
 * @brief	Fill current bitmap with a specified color.
 *
 * @param[in]	color		Color that used to fill bitmap. Format: 0xAARRGGBB
 * @param[in]	rect		Rectangle that specifies a region in bitmap, where the color will be filled.
 *							This can be <b>nil</b>, which means to fill the whole bitmap.
 */
-(void)fillRect: (unsigned int)color rect: (FSRectI*)rect;

/** @brief Free the object. */
-(void)dealloc;

@end
/** 
 * @brief	Enumeration for render color mode.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_RENDERCOLORMODE {
	/** @brief	Normal color mode. */
	e_colorModeNormal = 0,
	/** @brief	Map a color value to the color range defined by a background color and a foreground color. */
	e_colorModeMapping = 2
};

/** 
 * @brief	Enumeration for render content flags.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_RENDERCONTENTFLAG {
	/** @brief	If set, page content will be rendered. */
	e_renderPage = 0x01,
	/** @brief	If set, annotations will be rendered. */
	e_renderAnnot = 0x02
};

/** 
 * @brief	Enumeration for render device type.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_DEVICETYPE {
	/** @brief	Device type: printer. */
	e_deviceTypePrinter = 0,
	/** @brief	Device type: display device. */
	e_deviceTypeDisplay = 1
};

/**
 * @brief	Class to access PDF render operation.
 *
 * @details	PDF renderer is a graphics engine and is used to render page to a bitmap or a device.
 *			This class offers functions to set rendering options, and render page and annotations. <br>
 *			A ::FSRenderer object is created by function {@link FSRenderer::create:rgbOrder:} or {@link FSRenderer::createFromContext:deviceType:}.
 *			There are two ways to do rendering:
 *			<ul>
 *			<li>To render page and annotations, use functions {@link FSRenderer::startRender:matrix:pause:} and {@link FSRenderer::continueRender}.
 *				Function {@link FSRenderer::setRenderContent:} can be used to decide whether to render page and annotation both or not.</li>
 *			<li>To render a single annotation, use function {@link FSRenderer::renderAnnot:matrix:}.</li>
 *			</ul>
 */
@interface FSRenderer : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a renderer object from bitmap.
 *
 * @param[in]	bitmap		A bitmap used for rendering.
 * @param[in]	rgbOrder	<b>YES</b> means Foxit PDF SDK needs to use RGB byte-order
 *							(Red is in the lowest order) when rendering.<br>
 *							<b>NO</b> means Foxit PDF SDK needs to use BGR byte-order
 *							(Blue is in the lowest order) when rendering.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)create: (FSBitmap*)bitmap rgbOrder: (BOOL)rgbOrder;
/**
 * @brief	Create a renderer object from device context.
 *
 * @param[in]	context		A CGContextRef object.
 * @param[in]	deviceType	The device type of parameter <i>context</i>.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)createFromContext: (CGContextRef)context deviceType: (enum FS_DEVICETYPE)deviceType;
/**
 * @brief	Start rendering a PDF page.
 *
 * @details	It will take a long time to render a page with complex or large contents, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the rendering is not finished, please call function {@link FSRenderer::continueRender} to continue the rendering until it is finished.
 *
 * @param[in]	page		A PDF page. It should be parsed.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 * @param[out]	pause		Pause object which decides if the rendering process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the rendering process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet and function {@link FSRenderer::continueRender} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startRender: (FSPDFPage*)page matrix: (FSMatrix*)matrix pause: (FSPauseCallback*)pause;
/**
 * @brief	Continue rendering process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet and function {@link FSRenderer::continueRender} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueRender;
/**
 * @brief	Render a specified annotation.
 *
 * @details	When this function is called, render flag (set by function {@link FSRenderer::setRenderContent:} or by default) will be ignored.
 *
 * @param[in]	annot		An annotation object to be rendered.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix*)matrix;
/**
 * @brief	Set render flag to decide what content will be rendered.
 *
 * @details	If this function is not called, default value ({@link FS_RENDERCONTENTFLAG::e_renderPage} | {@link FS_RENDERCONTENTFLAG::e_renderAnnot}) will be used.
 *
 * @param[in]	renderContentFlag		Render content flags.
 *										Please refere to {@link FS_RENDERCONTENTFLAG::e_renderPage FS_RENDERCONTENTFLAG::e_renderXXX} values and this should be one or a combination of these values.
 */
-(void)setRenderContent: (unsigned int)renderContentFlag;
/**
 * @brief	Decide whether to transform annotation icon or not when display.
 *
 * @details	The flag set by this function is only useful for note and file attachment annotations.
 *			If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	transformAnnotIcon			<b>YES</b> means to transform annotation icon when display.
 *											<b>NO</b> means not to transform annotation icon when display.
 */
-(void)setTransformAnnotIcon: (BOOL)transformAnnotIcon;
/**
 * @brief	Set color mode.
 *
 * @details	If this function is not called, default value {@link FS_RENDERCOLORMODE::e_colorModeNormal} will be used.
 *
 * @param[in]	colorMode	Color mode value. It should be one of following values:
 *							<ul>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeNormal} means normal color mode.</li>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeMapping} means map a color value to the color range defined by a background color and a foreground color.
 *								If this mode is used, please call function {@link FSRenderer::setMappingModeColors:foreColor:} to set "background color" and "foreground color".</li>
 *							</ul>
 */
-(void)setColorMode: (enum FS_RENDERCOLORMODE)colorMode;
/**
 * @brief	Set background color and foreground color when color mode is set {@link FS_RENDERCOLORMODE::e_colorModeMapping}.
 *
 * @param[in]	backColor		The background color.
 * @param[in]	foreColor		The foreground color.
 */
-(void)setMappingModeColors: (unsigned int)backColor foreColor: (unsigned int)foreColor;
/**
 * @brief	Decide whether to use halftone for image stretching.
 *
 * @details	If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	isForceHalftone	<b>YES</b> means to use halftone for image stretching.
 *								<b>NO</b> means not to use halftone for image stretching.
 */
-(void)setForceHalftone: (BOOL)isForceHalftone;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *														 text search   							*
 *************************************************************************************************/

/**
 * @brief	Enumeration for search flag.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SEARCHFLAG {
	/** @brief	No special finding options.*/
	e_searchNormal = 0x00,
	/** @brief	If set, match the case of keyword when searching. */
	e_searchMatchCase = 0x01,
	/** @brief	If set, match the whole word of keyword when searching. */
	e_searchMatchWholeWord = 0x02,
	/** @brief	If set, match the key word consecutively when searching. For example, "CC" will be matched twice in "CCC". */
	e_searchConsecutive = 0x04
};

/**
 * @brief	Class to access PDF text search operation.
 *
 * @details	This class offers functions to do a text search and get the searching result:
 *			<ul>
 *			<li>To create a ::FSPDFTextSearch object, use function {@link FSPDFTextSearch::create:pause:}.</li>
 *			<li>To specify the searching pattern and options, use functions {@link FSPDFTextSearch::setKeyWords:}, {@link FSPDFTextSearch::setStartPage:} 
 *				and {@link FSPDFTextSearch::setFlag:}.</li>
 *			<li>To do the searching, use function {@link FSPDFTextSearch::findNext} or {@link FSPDFTextSearch::findPrev}.</li>
 *			<li>To get the searching result, use functions getMatchXXX() of the ::FSPDFTextSearch object.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 */
@interface FSPDFTextSearch : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a PDF text search object.
 *
 * @details	User can set a valid pause object in order to decide whether to pause the searching process or not 
 *			when the searching process is to be done in next or previous page.
 * 
 * @param[in]	pdfDoc		A PDF document instance.
 * @param[in]	pause		Pause object which decides if the searching process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the searching process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	A pointer point to a FSPDFTextSearch object.
 */
+(FSPDFTextSearch*)create: (FSPDFDoc*)pdfDoc pause: (FSPauseCallback*)pause;
/**
 * @brief	Set keywords to search.
 *
 * @param[in]	keyWords		The text content to be searched.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setKeyWords: (NSString *)keyWords;
/**
 * @brief	Set starting page index.
 * 
 * @details	If this function is not called, default value 0 will be used as the starting page index.
 *
 * @param[in]	pageIndex		Index of the page, from which the search starts. 
 *								Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setStartPage: (int)pageIndex;
/**
 * @brief	Set search flag.
 *
 * @details	If this function is not called, default value {@link FS_SEARCHFLAG::e_searchNormal} will be used.
 *
 * @param[in]	flag		Search flags. 
 *							Please refer to {@link FS_SEARCHFLAG::e_searchNormal FS_SEARCHFLAG::e_searchXXX} values and this can be one or combination of these values. 
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setFlag: (unsigned int)flag;
/**
 * @brief	Search for next matched pattern.
 *
 * @return	<b>YES</b> means the next match is found, while <b>NO</b> means no next match can be found or any other error.
 */
-(BOOL)findNext;
/**
 * @brief	Search for previous matched pattern.
 * 
 * @return	<b>YES</b> means the previous match is found, while <b>NO</b> means no previous match can be found or any other error.
 */
-(BOOL)findPrev;
/**
 * @brief	Get the count of rectangles for current match patten.
 *
 * @return	The count of rectangle for current match patten.
 */
-(int)getMatchRectCount;
/**
 * @brief	Get a specified rectangle of current match pattern.
 *
 * @param[in]	index		Rectangle index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFTextSearch::getMatchRectCount}.
 * 
 * @return	A FSRectF object that receives the specified rectangle.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getMatchRect: (int)index;
/**
 * @brief	Get the page index, to which current match belongs.
 *
 * @return	The index of the page, which contains the current match, starting from 0.
 */
-(int)getMatchPageIndex;
/**
 * @brief	Get the sentence that contains current match pattern.
 *
 * @return	The sentence content, which contains current match.
 */
-(NSString *)getMatchSentence;
/**
 * @brief	Get the index of the first character of current match pattern, based on the match sentence.
 *
 * @details	In a sentence, there may be more than 2 match patterns. This function can help to confirm which pattern in the sentence is just current match pattern.
 *
 * @return	The index of the first character of current match pattern, based on the match sentence, starting from 0.
 *			If there is any error, -1 will return.
 */
-(int)getMatchSentenceStartIndex;
/**
 * @brief	Get the index of the first character of current match pattern, based on current match page.
 *
 * @return	The index of the first character, in current match page, starting from 0.
 */
-(int)getMatchStartCharIndex;
/**
 * @brief	Get the index of the last character of current match pattern, based on current match page.
 *
 * @return	The index of the last character, in current match page, starting from 0.
 */
-(int)getMatchEndCharIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**   
 * @brief	Class to access PDF text selection.
 *
 * @details	PDF text selection is used for selecting text and retrieving text content from a specified PDF page. 
 *			This class offers functions to retrieve single character, single word, text content within specific character range or rectangle and so on.<br>
 *			A ::FSPDFTextSelect object is created by function {@link FSPDFTextSelect::create:}.
 */
@interface FSPDFTextSelect : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a PDF text selection instance according to specified page.
 *
 * @param[in]	pPage		A PDF page instance. This page should be parsed.
 *
 * @return	A new PDF text selection instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
+(FSPDFTextSelect*)create: (FSPDFPage*)pPage;
/** 
 * @brief	Get the PDF page associated with current text selection object.
 *
 * @return	The related PDF page instance.
 */
-(FSPDFPage*)getPage;
/** 
 * @brief	Get the count of all the characters in the page.
 * 
 * @return	Count of characters in the page.
 */
-(int)getCharCount;
/** 
 * @brief	Get the characters in a specified character index range.
 *
 * @param[in]	startIndex		Index of start character, which is the first character in the text content. 
 *								Valid range: from 0 to (<i>charcount</i> -1). <i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 * @param[in]	count			Count of characters to be retrieved. -1 means to get the whole characters from <i>startIndex</i> to the end of PDF page.
 *								Especially, when parameter <i>count</i> is larger than (<i>charcount</i> - start), all the rest character (from <i>startIndex</i>) will be retrieved. 
 *								<i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 *
 * @return	The characters within the specific character index range.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getChars: (int)startIndex count: (int)count;
/**
 * @brief	Get the character index at or around a specific position on the page, in PDF coordination system.
 *
 * @param[in]	x			Value of x position, in PDF coordination system.
 * @param[in]	y			Value of y position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value for character hit detection, in point units. This should not be a negative.
 *
 * @return	Index of the character, which is at or nearby point (x,y), starting from 0.
 *			Specially, if there are several characters near by point (x, y), the smallest character index will be returned.
 *			If there is no character at or nearby the point, -1 will be returned.
 */
-(int)getIndexAtPos: (float)x y: (float)y tolerance: (float)tolerance;
/**
 * @brief	Get the text within a rectangle, in PDF coordination system.
 *
 * @param[in]	rect	A rectangle region, in PDF coordination system.
 *
 * @return	Text string within the specified rectangle.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getTextInRect: (FSRectF*)rect;
/**
 * @brief	Get the word at or around a specific position on the page, in PDF coordination system.
 *
 * @details	For unicode characters, only a single unicode character can be retrieved at or around the specific position.
 *
 * @param[in]	x			Value of x position, in PDF coordination system.
 * @param[in]	y			Value of y position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value for word hit detection, in point units.This should not be a negative.
 *
 * @return	The range of character index for the word: <br>
 *			NSRange::location represents the index of the start character in the word.<br>
 *			NSRange::length represents the count of characters in the word. <br>
 */
-(NSRange)getWordAtPos: (float)x y: (float)y tolerance: (float)tolerance;
/**
 * @brief	Count the text rectangles in a specified character index range.
 *
 * @param[in]	start		Index of start character in the character index range.
 *							Valid range: from 0 to (<i>charcount</i> -1). <i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 * @param[in]	count		Count of characters in the character index range. -1 means to get the whole characters from <i>startIndex</i> to the end of PDF page.
 *
 * @return	The count of text rectangles in the specified character index range.
 */
-(int)getTextRectCount: (int)start count: (int)count;
/**
 * @brief	Get the text rectangle by the index.
 *
 * @param[in]	rectIndex		The index of the rectangle to be retrieved.
 *								Valid range: from 0 to (<i>count</i> -1). <i>count</i> is returned by function {@link FSPDFTextSelect::getTextRectCount:count:}.
 *
 * @return	A specified rectangle object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getTextRect: (int)rectIndex;
/**
 * @brief	Get the text trend (as rotation) of a specific rectangle.
 *
 * @param[in]	rectIndex		The index of the rectangle to be retrieved.
 *								Valid range: from 0 to (<i>count</i> -1). <i>count</i> is returned by function {@link FSPDFTextSelect::getTextRectCount:count:}.
 *
 * @return	Text trend, as rotation value.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 */
-(enum FS_ROTATION)getBaselineRotation: (int)rectIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**   
 * @brief	Class to access a PDF text link.
 *
 * @details	A text link is just text content, which represents a hypertext link to a website or a resource on the internet, 
 *			or an e-mail address.<br>
 *			This class offers functions to access a PDF text link to get information of the text link.<br>
 *			A ::FSPDFTextLink object is retrieved by function {@link FSPDFPageLinks::getTextLink:}.
 *
 * @see FSPDFPageLinks
 */
@interface FSPDFTextLink : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**  
 * @brief	Get URI string.
 *
 * @details	A text link's URI can be a hypertext link to a website or a resource on the internet. 
 *			It can also be an e-mail address.
 *
 * @return	URI string.
 */
-(NSString *)getURI;
/** 
 * @brief	Get the index of start character of current text link object, based on PDF page.
 *
 * @return	The index of start character, starting from 0.
 */
-(int)getStartCharIndex;
/** 
 * @brief	Get the index of last character of current text link object, based on PDF page.
 *
 * @return	The index of last character, starting from 0.
 */
-(int)getEndCharIndex;
/** 
 * @brief	Get the count of text rectangles of current text link object.
 *
 * @return	The count of text rectangles.
 */
-(int)getRectCount;
/** 
 * @brief	Get a text rectangle of current text link object, by index. 
 *
 * @param[in]	rectIndex		Index of a text rectangle. Valid range: from 0 to (<i>count</i>-1).
 *								<i>count</i> is returned by function {@link FSPDFTextLink::getRectCount}.
 *
 * @return	The specified text rectangle.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getRect: (int)rectIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access PDF page links.
 *
 * @details	 In a PDF page, there exist two kinds of links: text link and link annotation.
 *			<ul>
 *			<li>A text link is just text content, which represents a hypertext link to a website or a resource on the internet,
 *			    or an e-mail address.</li>
 *			<li>A link annotation is a kind of annotation and represents an action to be performed.</li>
 *			</ul>
 *			PDF page links is like a manager of page links. It offers function to access text link and link annotation directly.<br>
 *			A ::FSPDFPageLinks object is created by function {@link FSPDFPageLinks::create:}.
 *
 * @see	FSPDFTextLink
 * @see	FSLink
 */
@interface FSPDFPageLinks : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a PDF page links instance according to specified page.
 *
 * @param[in]	page		A PDF page instance. This page should be parsed.
 *
 * @return	A new PDF page links instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
+(FSPDFPageLinks*)create: (FSPDFPage*)page;
/**
 * @brief	Get the count of the URL formatted texts, in related PDF page.
 *
 * @return	The count of the text links.
 */
-(int)getTextLinkCount;
/**
 * @brief	Get a text link object by index.
 *
 * @param[in]	index		Index of a text link object. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFPageLinks::getTextLinkCount}.
 *
 * @return	The specified text link object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFTextLink*)getTextLink: (int)index;
/**
 * @brief	Get the count of the annotation links, in related PDF page.
 * 
 * @return	The count of the annotation links.
 */
-(int)getLinkAnnotCount;
/**
 * @brief	Get a specified annotation link by index.
 * 
 * @param[in]	index		Index of link annotation. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFPageLinks::getLinkAnnotCount}.
 *
 * @return	A link annotation object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSLink*)getLinkAnnot: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *														 form       							*
 ************************************************************************************************/

/**
 * @brief	Enumeration for form control type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_FORMFIELDTYPE {
    /** @brief	Form field type: unknown. */
    e_formFieldUnknownType = 0,
    /** @brief	Form field type: push button. */
    e_formFieldPushButton = 1,
    /** @brief	Form field type: check box. */
    e_formFieldCheckBox = 2,
    /** @brief	Form field type: radio button. */
    e_formFieldRadioButton = 3,
    /** @brief	Form field type: combo box. */
    e_formFieldComboBox = 4,
    /** @brief	Form field type: list box. */
    e_formFieldListBox = 5,
    /** @brief	Form field type: text field. */
    e_formFieldTextField = 6,
    /** @brief	Form field type: signature field. */
    e_formFieldSignature = 7
};

/**
 * @brief	Enumeration for form field flags.
 *
 * @details	Values of this enumeration can be used alone or in a combination.
 */
enum FS_FORMFIELDFLAGS {
    /** @brief	The field is read only and no editing is allowed. */
    e_formFieldFlagReadonly		= 0x01,
    /** @brief	The field must have a value at the time it is exported by a submit-form action. */
    e_formFieldFlagRequired		= 0x02,
    /** @brief	The field must not be exported by a submit-form action. */
    e_formFieldFlagNoExport		= 0x04,
    /**
      * @brief	(Only useful for radio button)Unable to turn the radio button off.
      *
      * @details	For radio button only: if set, one radio button must be selected at any time;
      *			otherwise, when the selected radio button is clicked, it will be turned off,
      *			(leaving no radio button selected at this time).
      */
    e_formFieldFlagButtonNoToggleToOff	= 0x100,
    /**
      * @brief	(Only useful for radio button) Put radio buttons with same value in unison
      *
      * @details	If set, radio buttons with same value in a field will be turned on or off
      *			in unison (either all on, or all off). If cleared, all buttons are
      *			mutually exclusive.
      */
    e_formFieldFlagButtonRadiosInUnison	= 0x200,
    /** @brief	(Only useful for text field)If set, the text field can contain multiple lines of text. */
    e_formFieldFlagTextMultiline	= 0x100,
    /**
      * @brief	(Only useful for text field)If set, the text field is used as a password field.
      *
      * @details	If a text field is used as a password field, the typed password string should not be displayed or exported.
      */
    e_formFieldFlagTextPassword	= 0x200,
    /**
      * @brief	(Only useful for text field)Never show scroll bar for a text field.
      *
      * @details	If set, do not scroll (vertically for multiple-line fields, or horizontally for single-line fields)
      *			to accommodate more text than fits within the field's rectangle.
      *			If the field is full, no further text is accepted.
      */
    e_formFieldFlagTextDoNotScroll	= 0x400,
    /**
      * @brief	(Only useful for text field)Use combs.
      *
      * @details	If set, the field is automatically divided into as many equally spaced positions,
      *			or combs, as the value of maximum length of a field's text, and the text is laid out into those combs.
      */
    e_formFieldFlagTextCombo	= 0x800,
    /**
      * @brief	(Only useful for combo box)If set, the combo box includes an editable text control with a drop list, otherwise, it includes only a drop list.
      */
    e_formFieldFlagComboEdit	= 0x100,
    /** @brief	(Only useful for combo box and list box)If set, more than one items can be selected; otherwise, only one item can be selected in one time. */
    e_formFieldFlagChoiseMultiselect	= 0x100
};

/**
 * @brief	Class to access interactive form.
 *
 * @details	An interactive form -- sometimes referred to as an AcroForm -- is a collection of fields for gathering information interactively from the user.
 *			A PDF document may contain any number of fields appearing on any combination of pages, all of which make up a single, global interactive form spanning the entire document.
 *			Arbitrary subsets of these fields can be imported or exported from the document.<br>
 *			Function {@link FSPDFDoc::hasForm} can be used to judge if a PDF document has interactive form, and function {@link FSPDFDoc::getForm} can be used to get the interactive form object.
 *			This class also offers functions to access form fields, import/export form data and other features. For example:
 *			<ul>
 *			<li>To access form fields, use functions {@link FSForm::getFieldCount:} and {@link FSForm::getField:index:}.</li>
 *			<li>To import form data from an XML file, use function {@link FSForm::importFromXML:};
 *				to export form data to an XML file, use function {@link FSForm::exportToXML:}.</li>
 *			<li>To access form filler, use function {@link FSForm::getFormFiller}.</li>
 *			</ul>
 *
 * @see	FSPDFDoc
 */
@interface FSForm : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Get count of form fields, whose names satisfy the specified filter name.
 *
 * @param[in]	filter		A UTF-8 encoded string as the filter. <br>
 *							If this is <b>nil</b> or an empty string, that means to count all fields.<br>
 *							If this is valid, that means to count those fields whose name is partially matched by parameter <i>filter</i>.
 *							For example, if parameter <i>filter</i> is "text1", the filter will match text1.0, text1.2.0, etc; but not match test10 or test11.1.
 *
 * @return	The count of the form fields.
 */
-(int)getFieldCount: (NSString *)filter;

/**
 * @brief	Get a form field by index, whose names satisfy the specified filter name.
 *
 * @param[in]	filter		A UTF-8 encoded string as the filter. <br>
 *							If this is <b>nil</b> or an empty string, that means to count all fields.<br>
 *							If this is valid, that means to count those fields whose name is partially matched by parameter <i>filter</i>.
 *							For example, if parameter <i>filter</i> is "text1", the filter will match text1.0, text1.2.0, etc; but not match test10 or test11.1.
 * @param[in]	index		Form field index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSForm::getFieldCount:} with same parameter <i>filter</i>.
 *
 * @return	A form field object.
 *			If no form field can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSFormField*)getField: (NSString *)filter index: (int)index;

/**
 * @brief	Get the form filler.
 *
 * @return	The form filler object.
 *			If the form filler has not been created yet, this function will return <b>nil</b>.
 */
-(FSFormFiller*)getFormFiller;

/**
 * @brief	Reset data in all fields to their default value.
 *
 * @return	<b>YES</b> means reseting operation is successful, while <b>NO</b> means failure.
 */
-(BOOL)reset;

/**
 * @brief	Export the form data to an XML file.
 *
 * @param[in]	path	XML file path, which specifies the XML file that form data will be exported to.
 *						It should be an XML file, otherwise this function will fail.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)exportToXML: (NSString *)path;

/**
 * @brief	Import the form data from an XML file.
 *
 * @param[in]	path	XML file path, which specifies the XML file that form data will be imported from.
 *						It should be an XML file, otherwise this function will fail.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)importFromXML: (NSString *)path;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to access a form field.
 *
 * @details	In a PDF document, form fields appear on any combination of pages and all of them make up a single, global interactive form spanning the entire document.
 *			Function {@link FSForm::getField:index:} can use to get a form field from interactive form.
 *			This class offers functions to get some information/properties of a form field, and also offers functions to get form control from form field.
 *
 * @see	FSForm
 */
@interface FSFormField : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Get the field type.
 *
 * @return	Form field type.
 *			Please refer to {@link FSM_FORMFIELDTYPE::e_formFieldUnknownType FSM_FORMFIELDTYPE::e_formFieldXXX} values and it would be one of these values.
 */
-(enum FS_FORMFIELDTYPE)getType;

/**
 * @brief	Get the field flags.
 *
 * @return	Form field flags.
 *			Please refer to {@link FSM_FORMFIELDFLAGS::e_formFieldFlagReadonly FSM_FORMFIELDFLAGS::e_formFieldXXX} values and it would be one of a combination of these values.
 */
-(enum FS_FORMFIELDFLAGS)getFlags;

/**
 * @brief	Get field name.
 *
 * @return	Field name string, in UTF-8 encoding.
 *			If there is any error, this function will return an empty string.
 */
-(NSString *)getName;

/**
 * @brief	Get default value of current form field.
 *
 * @return	Default value string, in UTF-8 encoding.
 *			If there is any error, this function will return an empty string.
 */
-(NSString *)getDefaultValue;

/**
 * @brief	Get value of current form field.
 *
 * @return	Value string, in UTF-8 encoding.
 *			If there is any error, this function will return an empty string.
 */
-(NSString *)getValue;

/**
 * @brief	Get count of form controls in a specified PDF page.
 *
 * @param[in]	page		The PDF page object. It should not be <b>nil</b>.
 *
 * @return	The count of the form controls in the specified PDF page.
 */
-(int)getControlCount: (FSPDFPage*)page;

/**
 * @brief	Get a form control by index, in a specified PDF page.
 *
 * @param[in]	page		The PDF page object. It should not be <b>nil</b>.
 * @param[in]	index		Form control index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSFormField::getControlCount:} with same parameter <i>page</i>.
 *
 * @return	A form control object.
 *			If no form control can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSFormControl*)getControl: (FSPDFPage*)page index: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to access a form control.
 *
 * @details	In Foxit PDF SDK, a form control is also treated as a widget annotation, so class ::FSFormField is derived from class ::FSAnnot and can access to annotation's common properties.<br>
 *			So a form control object can be retrieved by following methods:
 *			<ul>
 *			<li>from a form field, use function {@link FSFormField::getControl:index:}, as a form control directly.</li>
 *			<li>from a PDF page, use functions {@link FSPDFPage::getAnnot:}, {@link FSPDFPage::getAnnotAtPos:tolerance:}, or {@link FSPDFPage::getAnnotAtDevicePos:position:tolerance:},
 *				as a widget annot.</li>
 *			</ul>
 *			Specially, when the related field type is {@link FSM_FORMFIELDTYPE::e_formFieldSignature}, the essential class of this form control is ::FSSignature.
 *
 * @see	FSFormField
 * @see	FSAnnot
 * @see	FSSignature
 */
@interface FSFormControl : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Get the related form field.
 *
 * @return	The related form field object.
 *			If no related form field can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSFormField*)getField;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	A callback function used as a timer on every time interval.
 *
 * @param[in]	timer	Identifier of a timer.
 */
typedef void (*FS_CALLBACK_TIMER)(int timer);

/**
 * @brief	Class to represents a callback object to assist form filler.
 *
 * @details	All the pure virtual functions in this class are used as callback functions and should be implemented by user.<br>
 * 			This is an assistant class for form filler.
 */
@interface FSFormFillerAssist : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/** @brief Get the version of derived implementation, for compatibility reason. */
-(int)getVersion;

/**
 * @brief	A callback function used to refresh the specified area on a specified page.
 *
 * @param[in]	page		A PDF page object.
 * @param[in]	pdfRect		A rectangle that specifies the area on the page to be redrawn.
 */
-(void)refresh: (FSPDFPage*)page pdfRect: (FSRectF*)pdfRect;

/**
 * @brief	A callback function used to set a system timer.
 *
 * @details	This callback function is called to install a system timer.
 *			When a time-out value is specified, and every time when a time-out occurs,
 *			the system passes a message to the timer callback function.
 *
 * @param[in]	elapse		Specifies the time-out value, in milliseconds.
 * @param[in]	timerFunc	Function pointer of a callback function as timer.
 * @param[out]	timerID		The timer identifier of the new timer if the function is finished successfully.
 *							An application passes this value to the FSFormFillerAssist::killTimer method to kill
 *							the timer. Nonzero if it is successful; otherwise, it is zero.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setTimer: (int)elapse timerFunc: (FS_CALLBACK_TIMER)timerFunc timerID: (int *)timerID;

/**
 * @brief	A callback function used to kill the timer event by timer identifier.
 *
 * @param[in]	timerID		The timer ID, returned by an earlier calling of callback function {@link FSFormFillerAssist::setTimer:timerFunc:timerID:}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)killTimer: (int)timerID;

/**
 * @brief	A callback function which is triggered when the focus is set to a form control.
 *
 * @details	Currently, only support text field and combobox field.
 *
 * @param[in]	control		The form control object, to which the focus is set.
 * @param[in]	fieldValue	The value of form field associated with the control. It should be in UTF-8 encoding.
 */
-(void)focusGotOnControl: (FSFormControl*)control fieldValue: (NSString *)fieldValue;

/**
 * @brief	A callback function which is triggered when the focus is lost from a form control.
 *
 * @details	Currently, only support text field and combobox field.
 *
 * @param[in]	control		The form control object, to which the focus is lost.
 * @param[in]	fieldValue	The value of form field associated with the control. It should be in UTF-8 encoding.
 */
-(void)focusLostFromControl: (FSFormControl*)control fieldValue: (NSString *)fieldValue;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represent a form filler, used for filling PDF form.
 *
 * @details	This class is used for filling PDF form. There should be only one form filler object for an interactive form,
 *			so do not call function {@link FSFormFiller::create:assist:} for one form more than one time.
 *
 * @note	User is recommended to implement a ::FSActionHandler and set it to Foxit PDF SDK by function {@link FSLibrary::setActionHandler:},
 *			in order to implement more features of form filler.
 */
@interface FSFormFiller : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Create a form filler object. It should not be called one more time if the form is the same.
 *
 * @details	There can be only one form filler for a form.
 *
 * @param[in]	form		A PDF form.
 * @param[in]	assist		An assistant class for form filler. This should be implemented by user.
 *
 * @return	A form filler object.
 *			If there is any error, this function will return <b>nil</b>.
 */
+(FSFormFiller*)create: (FSForm*)form assist: (FSFormFillerAssist*)assist;

/**
 * @brief	Draw the currently focused form control on the page.
 *
 * @details	If there is no focused form control on the page, nothing will be drawn.
 *			The focused form control has to be the topmost visible element, so that it should be always rendered after page content and annotations have been rendered.
 *
 * @param[in]	page		A PDF page object.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 * @param[in]	renderer	The renderer used for rendering.
 */
-(void)render: (FSPDFPage*)page matrix:(FSMatrix*)matrix renderer:(FSRenderer*)renderer;

/**
 * @brief	Triggered when tapping the specified page.
 *
 * @param[in] page		The PDF page object.
 * @param[in] point		The PDF point in PDF coordinate system.
 *
 * @return	 <b>YES</b> if successful, <b>NO</b> if failed.<br>
 */
-(BOOL)tap: (FSPDFPage*)page point: (FSPointF*)point;

/**
 * @brief	Call this function when a character code is about to be inputted to a form field.
 *
 * @param[in] charCode	The character code, UTF-8 encoding.
 *
 * @return	 <b>YES</b> if successful, <b>NO</b> if failed.<br>
 */
-(BOOL)input: (unsigned int)charCode;

/**
 * @brief	Decide whether to highlight form fields or not.
 *
 * @details	All the form field types can be highlighted, except push button fields.
 *
 * @param[in]	isHighlight		A boolean value that indicates whether to highlight form fields or not:<br>
 *								<b>YES</b> means to highlight form fields, and <b>NO</b> means not to highlight form fields.
 */
-(void)highlightFormFields: (BOOL)isHighlight;

/**
 * @brief	Set the highlight color used for highlighting form fields.
 *
 * @param[in]	color	The highlight color.
 */
-(void)setHighlightColor: (unsigned int)color;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Enumeration for signature states.
 *
 * @details	Values of this enumeration can be used alone or in combination.<br>
 *			These values can be divided into four parts:
 *			<ul>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateUnknown FS_SIGNATURESTATES::e_signatureStateXXX} values represent signed state, before signature is verified successfully.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyValid FS_SIGNATURESTATES::e_signatureStateVerifyXXX} values represent the verified state of a signature.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyIssueValid FS_SIGNATURESTATES::e_signatureStateVerifyIssueXXX} values represent the verified state of issue for a signature, with more details.</li>
 *			<li>{@link FS_SIGNATURESTATES::e_signatureStateVerifyTimestampNone FS_SIGNATURESTATES::e_signatureStateVerifyTimestampXXX} values represent the verified state for time stamp, with more details.</li>
 *			</ul>
 */
enum FS_SIGNATURESTATES {
    /** @brief	Unknown signature. */
    e_signatureStateUnknown = 0x00000000,
    /** @brief	Signature does not have any data for signing. */
    e_signatureStateNoSignData = 0x00000200,
    /** @brief	Unsigned signature.*/
    e_signatureStateUnsigned = 0x00000001,
    /** @brief	Signed signature. */
    e_signatureStateSigned = 0x00000002,
    /** @brief	Verification state of a signature is valid. */
    e_signatureStateVerifyValid = 0x00000004,
    /** @brief	Verification state of a signature is invalid. */
    e_signatureStateVerifyInvalid = 0x00000008,
    /** @brief	Signature data is destroyed (the signature data cannot be parsed properly). */
    e_signatureStateVerifyErrorData = 0x00000010,
    /** @brief	Unsupported signature. */
    e_signatureStateVerifyNoSupportWay = 0x00000020,
    /** @brief	Non expected byte range. */
    e_signatureStateVerifyErrorByteRange = 0x00000040,
    /** @brief	The document has changed within the scope of the signature. */
    e_signatureStateVerifyChange = 0x00000080,
    /** @brief	Signature cannot be trusted (containing aggression). */
    e_signatureStateVerifyIncredible = 0x00000100,
    /** @brief	Verification state of the issuer is valid. */
    e_signatureStateVerifyIssueValid = 0x00001000,
    /** @brief	Verification state of the issuer is unknown. */
    e_signatureStateVerifyIssueUnknown = 0x00002000,
    /** @brief	Certificate for verifying issuer is revoked. */
    e_signatureStateVerifyIssueRevoke = 0x00004000,
    /** @brief	Certificate for verifying issuer is expired. */
    e_signatureStateVerifyIssueExpire = 0x00008000,
    /** @brief	Not check the issuer. */
    e_signatureStateVerifyIssueUncheck = 0x00010000,
    /** @brief	The verified issue is current issuer. */
    e_signatureStateVerifyIssueCurrent = 0x00020000,
    /** @brief	No timestamp or not check timestamp. */
    e_signatureStateVerifyTimestampNone = 0x00040000,
    /** @brief	The signature is a timestamp signature. */
    e_signatureStateVerifyTimestampDoc = 0x00080000,
    /** @brief	Verification state of the timestamp is valid. */
    e_signatureStateVerifyTimestampValid = 0x00100000,
    /** @brief	Verification state of the timestamp is invalid. */
    e_signatureStateVerifyTimestampInvalid = 0x00200000,
    /** @brief	Verification state of the timestamp is expired. */
    e_signatureStateVerifyTimestampExpire = 0x00400000,
    /** @brief	Verification state of the timestamp issuer is unknown. */
    e_signatureStateVerifyTimestampIssueUnknown = 0x00800000,
    /** @brief	Verification state of the timestamp issuer is valid. */
    e_signatureStateVerifyTimestampIssueInvalid = 0x01000000,
    /** @brief	Verification state of the timestamp time is valid, since the times is before the expiration date. */
    e_signatureStateVerifyTimestampTimeBefore = 0x02000000
};

/**
 * @brief	Enumeration for signature appearance flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SIGNATUREAPFLAGS {
    /** @brief      If set, show Foxit flag on signature appearance. */
    e_signatureAPFlagFoxitFlag = 0x0001,
    /** @brief      If set, show label on signature appearance. */
    e_signatureAPFlagLabel = 0x0002,
    /** @brief      If set, show reason on signature appearance. */
    e_signatureAPFlagReason = 0x0004,
    /** @brief      If set, show signing time on signature appearance. */
    e_signatureAPFlagSigningTime = 0x0008,
    /** @brief      If set, show distinguish name on signature appearance. */
    e_signatureAPFlagDN = 0x0010,
    /** @brief      If set, show location on signature appearance. */
    e_signatureAPFlagLocation = 0x0020,
    /** @brief      If set, show signer on signature appearance. */
    e_signatureAPFlagSigner = 0x0040,
    /** @brief      If set, show bitmap on signature appearance. */
    e_signatureAPFlagBitmap = 0x0080,
    /** @brief      If set, show text content on signature appearance. */
    e_signatureAPFlagText = 0x0100
};

/**
 * @brief	Enumeration for signature key name.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_SIGNATUREKEYNAME {
    /** @brief	Signature key name: signer. */
    e_signatureKeyNameSigner = 0,
    /** @brief	Signature key name: location. */
    e_signatureKeyNameLocation = 1,
    /** @brief	Signature key name: reason. */
    e_signatureKeyNameReason = 2,
    /** @brief	Signature key name: contact information. */
    e_signatureKeyNameContactInfo = 3,
    /** @brief	Signature key name: distinguish name. */
    e_signatureKeyNameDN = 4,
    /** @brief	Signature key name: text content. */
    e_signatureKeyNameText = 5,
    /** @brief	Signature key name: filter, used to decide which registered signature handler is used to sign/verify signature. */
    e_signatureKeyNameFilter = 6,
    /** @brief	Signature key name: sub filter, used to decide which registered signature handler is used to sign/verify signature. */
    e_signatureKeyNameSubFilter = 7
    
};

/**
 * @brief	Enumeration for signature digest algorithm.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DIGEST_ALGORITHM {
    /** @brief	Signature digest algorithm: sha1 algorithm. */
    e_digestSHA1 = 0,
    /** @brief	Signature digest algorithm: sha256 algorithm. */
    e_digestSHA256 = 1,
    /** @brief	Signature digest algorithm: sha384 algorithm. */
    e_digestSHA384 = 2,
    /** @brief	Signature digest algorithm: sha512 algorithm. */
    e_digestSHA512 = 3
};
    
/**
 * @brief	Class to represent a signature.
 *
 * @details	A digital signature (PDF 1.3) can be used to authenticate the identity of a user and the document's contents.
 *			It stores information about the signer and the state of the document when it was signed.
 *			The signature is contained in a signature field, as a type of form field, so class ::FSSignature is derived from class ::FSFormControl.
 *			A ::FSSignature object can be gotten/added by following methods:
 *			<ul>
 *			<li>To count and get signature from document, use functions {@link FSPDFDoc::getSignatureCount} and {@link FSPDFDoc::getSignature:}.</li>
 *			<li>To add a new signature, use function {@link FSPDFPage::addSignature:}.</li>
 *			<li>If the related field type of a ::FSFormControl object is {@link FSM_FORMFIELDTYPE::e_formFieldSignature}, the essential class of this form control is ::FSSignature.
 *				So this ::FSFormControl object can be converted to be used as a ::FSSignature object.</li>
 *			</ul>
 *			In a signature, filter and sub filter keys are used to specify the name of signature handler which will be used to sign and verify the signature.
 *			Before sign a signature, please ensure the signature handler has been registered to Foxit PDF SDK with the same filter and sub filter of the signature.
 *			Before verify a signature, please ensure a signature handler with the same name, which is specified by signature's filter and sub filter keys, has been registered to Foxit PDF SDK.
 *			Function {@link FSLibrary::registerDefaultSignatureHandler} can be used to register the default AdobePPKLite handler, with filter ("Adobe.PPKLite") and sub filter ("adbe.pkcs7.detached" or
 *             "adbe.pkcs7.sha1").
 *			This class offers functions to access signature information/properties, sign or verify a signature, and so on. For example:
 *			<ul>
 *			<li>To sign an unsigned signature, use functions {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} and {@link FSSignature::continueSign}.
 *				When signing a signature successfully, user is strongly recommended to close current document and then open the signed PDF document to do following operation.</li>
 *			<li>To verify a signed signature, use functions {@link FSSignature::startVerify:clientData:} and {@link FSSignature::continueVerify}.</li>
 *			<li>To access signature dictionary directly, use function {@link FSSignature::getSignatureDict}.</li>
 *			</ul>
 *			Before signing an unsigned signature, user can call following functions to set information for signing and signed appearance:<br>
 *			{@link FSSignature::setAppearanceFlags:}, {@link FSSignature::setSigningTime:}, {@link FSSignature::setKeyValue:value:}, {@link FSSignature::setBitmap:},
 *			{@link FSSignature::setAppearanceContent:}.<br>
 *			If an unsigned signature has been set some information for signing, but the document is saved directly or closed without signing the signature,
 *			these data (including filter and sub filter) will be lost in the saved document or in the closed document. When the document is opened again,
 *			the unsigned signature needs to be specified at least filter and sub filter for signing; otherwise, this signature cannot be signed.
 *
 * @see	FSFormControl
 * @see FSPDFDoc
 * @see FSPDFPage
 */
@interface FSSignature : FSFormControl
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Check whether current signature is signed or not.
 *
 * @return	<b>YES</b> means current signature is signed, and <b>NO</b> means not.
 */
-(BOOL)isSigned;

/**
 * @brief	Start signing current signature if current signature is unsigned.
 *
 * @details	This function is used for an unsigned signature.
 *			Filter and sub filter keys of current signature specify the name of signature handler which will be used to sign current signature.
 *			So before signing, please ensure:
 *			<ul>
 *			<li>Current signature has valid filter and sub filter string values.</li>
 *			<li>The necessary signature handler has been registered by function {@link FSLibrary::registerDefaultSignatureHandler} (for default siganture handler).</li>
 *			</ul>
 *			It may take a long time to sign a signature, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the signing proecess is not finished, please call function {@link FSSignature::continueSign} to continue the signing process until it is finished.
 *
 * @param[in]	savePath		The path for saving the signing result. The signed document would be saved to another PDF file.
 * @param[in]	certPath		The pfx certificate file path, which will be used for signing. It should be in UTF-8 encoding. It should be a valid path.
 * @param[in]	certPassword	The password string, used to open the cert file. If this is <b>nil</b> or empty, that means no password is required.
 *								It should be valid if parameter <i>passwordLen</i> is above 0.
 * @param[in]	digestAlgorithm	The algorithm of message digest for signed data. Please refer to {@link FS_DIGEST_ALGORITHM::e_digestSHA1 FS_DIGEST_ALGORITHM::e_digestXXX} values
 *								and it should be one of these values.
 * @param[in]	pause			Pause object which decides if the signing process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the signing process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	clientData		Pointer to a user-defined object, which will be passed to call back functions in FSSignatureHandler.
 *								This is useless if the default handler will be used to sign current signature.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the signing is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the signing process is not finished yet and function {@link FSSignature::continueSign} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 *
 * @note	When signing a signature successfully, user is strongly recommended to close current document and then open the signed PDF document to do following operation.
 */
-(enum FS_PROGRESSSTATE)startSign: (NSString *)savePath certPath: (NSString *)certPath certPassword: (NSString*)certPassword digestAlgorithm: (enum FS_DIGEST_ALGORITHM)digestAlgorithm pause: (FSPauseCallback*)pause clientData: (void*)clientData;

/**
 * @brief	Continue signing process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the signing is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the signing process is not finished yet and function {@link FSSignature::continueSign} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueSign;

/**
 * @brief	Start verifying current signature if current signature is signed.
 *
 * @details	This function is used for a signed signature.
 *			Filter and sub filter keys of current signature specify the name of signature handler which will be used to verify current signature.
 *			So before verifying, please ensure the necessary signature handler has been registered by function {@link FSLibrary::registerDefaultSignatureHandler} (for default siganture handler) or
 *			by function {@link FSLibrary::registerDefaultSignatureHandler} (for customized signature handler).<br>
 *			It may take a long time to verify a signature, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the verifying proecess is not finished, please call function {@link FSSignature::continueVerify} to continue the verifying process until it is finished.
 *
 * @param[in]	pause			Pause object which decides if the verifying process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the verifying process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	clientData		Pointer to a user-defined object, which will be passed to call back functions in FSSignatureHandler.
 *								This is useless if the default handler will be used to verify current signature.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the verifying is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the verifying process is not finished yet and function {@link FSSignature::continueVerify} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startVerify: (FSPauseCallback*)pause clientData:(void*)clientData;

/**
 * @brief	Continue verifying process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the verifying is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the verifying process is not finished yet and function {@link FSSignature::continueVerify} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueVerify;

/**
 * @brief	Get current state.
 *
 * @details	<ul>
 *			<li>Before verifying a signature, this function is to get the state about if current signature is signed
 *				or if current signature is lack of data for signing.</li>
 *			<li>After verifying a signature, this function is to get the verified state -- which indicates that the verified signature is signed;
 *				if the verified signature is still unsigned, this function will get the unsigned state instead.</li>
 *			</ul>
 *
 * @return	The value of signature state.
 *			Please refer to {@link FS_SIGNATURESTATES::e_signatureStateUnknown FS_SIGNATURESTATES::e_signatureStateXXX} values and it would be one or combination of them.<br>
 *			Specially, if the returned state is {@link FS_SIGNATURESTATES::e_signatureStateNoSignData}, that means current signature has no data for signing,
 *			and please at least call function {@link FSSignature::setKeyValue:value:} to set necessary filter and sub filter to current signature.
 *			Use can also call following functions to set other data for signing and signed appearance before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:}<br>
 *			{@link FSSignature::setAppearanceFlags:}, {@link FSSignature::setSigningTime:}, {@link FSSignature::setKeyValue:value:}, {@link FSSignature::setBitmap:},
 *			{@link FSSignature::setAppearanceContent:}.
 */
-(unsigned int)getState;

/**
 * @brief	Clear the data and appearance if current signature is singed and verified valid.
 *
 * @details   This function is used for a signed and valid signature.
 *
 * @return	<b>YES</b> means clear the data and appearance successfully, while <b>NO</b> means no need to clear data and appearance or any error.
 */
-(BOOL)clearSignedData;

/**
 * @brief	Get the PDF document, which current signature belongs to.
 *
 * @return	A ::FSPDFDoc object.
 */
-(FSPDFDoc*)getDocument;

/**
 * @brief	Get signature appearance flags.
 *
 * @details	Signature appearance flags indicate which information will be shown.
 *			Currently, this is only useful after {@link FSSignature::setAppearanceFlags:} is called successfully.
 *			For a signature gotten from PDF document, returned value of this function would be useless.
 *
 * @return	Signature appearance flags.
 *			Please refer to {@link FS_SIGNATUREAPFLAGS::e_signatureAPFlagFoxitFlag FS_SIGNATUREAPFLAGS::e_signatureAPFlagXXX} values and it would be one or a combination of them.
 */
-(unsigned int)getAppearanceFlags;

/**
 * @brief	Set signature appearance flags.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature. <br>
 *			Signature appearance flags indicate which information will be shown in the signed appearance.
 *			If customized appearance content has been set by function {@link FSSignature::setAppearanceContent:}, appearance flags will be ignored.
 *
 * @param[in]	apFlags	Signature appearance flags.
 *						Please refer to {@link FS_SIGNATUREAPFLAGS::e_signatureAPFlagFoxitFlag FS_SIGNATUREAPFLAGS::e_signatureAPFlagXXX} values and it should be one or a combination of them.
 */
-(void)setAppearanceFlags: (unsigned int)apFlags;

/**
 * @brief	Get time of signing.
 *
 * @return	A Foxit::DateTime object that receives the signing time.
 *			If no signing time is found or any error, this function will return a ::FSDateTime with all values 0.
 */
-(FSDateTime*)getSigningTime;

/**
 * @brief	Set time of signing.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.
 *
 * @param[in]	signTime	The signing time.
 */
-(void)setSigningTime: (FSDateTime*)signTime;

/**
 * @brief	Get the string value for specified key name.
 *
 * @details	This function is used to get string value of some key in signature dictionary, such as "Reason", "Location" and so on.
 *			Specially, filter and sub filter are used to specify which registered signature handler will be used to sign/verify current signature.
 *
 * @param[in]	key		Key name.
 *						Please refer to {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSigner FS_SIGNATUREKEYNAME::e_signatureKeyNameXXX} values and it should be one of them.
 *
 * @return	The string value, in UTF-8 encoding.
 */
-(NSString *)getKeyValue: (enum FS_SIGNATUREKEYNAME)key;

/**
 * @brief	Set the string value for specified key name.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.<br>
 *			This function is used to set string value of some key in signature dictionary, such as signer, reason, location and so on.
 *			Specially, filter and sub filter are used to specify which registered signature handler will be used to sign/verify current signature.<br>
 *			If application does not set filter and sub filter for current signature, Foxit PDF SDK will use filter "Adobe.PPKLite" and sub filter"adbe.pkcs7.detached" by default.
 *			And application should ensure to register a signature handler with this filter and sub filter before signing or verifying current signature.<br>
 *			If application wants to use other signature handler, please set the filter and sub filter name of that signature handler to current signature,
 *			and also ensure the handler has been registered before signing and verifying current signature.<br>
 *
 * @param[in]	key		Key name.
 *						Please refer to {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameSigner FS_SIGNATUREKEYNAME::e_signatureKeyNameXXX} values and it should be one of them.
 * @param[in]	value 	New string value, in UTF-8 encoding.
 *						This should not be <b>nil</b> or empty, if parameter <i>key</i> is {@link FS_SIGNATUREKEYNAME::e_signatureKeyNameFilter}.
 */
-(void)setKeyValue: (enum FS_SIGNATUREKEYNAME)key value: (NSString *)value;

/**
 * @brief	Get a bitmap used for the signature appearance.
 *
 * @return	The bitmap used in appearance.
 *			If no bitmap is used in appearance or there is any error, <b>nil</b> will be returned.
 */
-(FSBitmap*)getBitmap;

/**
 * @brief	Set a bitmap for the signature appearance.
 *
 * @details	This function is recommended to be used before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for an unsigned signature.
 *			If customized appearance content has been set by function {@link FSSignature::setAppearanceContent:}, the bitmap will not be used in signed appearance.
 *
 * @param[in]	bitmap		A bitmap to be set to the appearance. It should be valid.
 */
-(void)setBitmap: (FSBitmap*)bitmap;

/**
 * @brief	Get signature dictionary.
 *
 * @details	Signature dictionary is a part of signature field dictionary.
 *
 * @return	The signature dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getSignatureDict;

/**
 * @brief	Set customized appearance content (as low level drawing commands) for signed signature appearance.
 *
 * @details	This function can only be used for an unsigned signature, before calling function {@link FSSignature::startSign:certPath:certPassword:digestAlgorithm:pause:clientData:} for the unsigned signature.
 *			Once customized appearance content is set, it will be used as the signed appearance and appearance flags set by function {@link FSSignature::setAppearanceFlags:} will be ignored.
 *
 * @param[in]	appearanceContent		Customized appearance content, in UTF-8 encoding.
 *										A sequence of drawing commands to be used for the appearance, for example "10 10 m 20 10 l S".
 */
-(void)setAppearanceContent: (NSString *)appearanceContent;

/** @brief Free the object. */
-(void)dealloc;

@end

#ifdef __cplusplus
}
#endif

